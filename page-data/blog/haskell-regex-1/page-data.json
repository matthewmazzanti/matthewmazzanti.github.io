{"componentChunkName":"component---src-components-blog-template-tsx","path":"/blog/haskell-regex-1/","result":{"data":{"markdownRemark":{"html":"<section><p>This post is a first in a larger series where I rebuild an\n<a href=\"https://en.wikipedia.org/wiki/Ed_(text_editor)\">ed</a> clone in Haskell. My goal is\nto use this implementation as a basic platform to test out some new algorithms\nI've been researching to do text processing, the first of which will be related\nto regex. I hope you stay tuned!</p><p>The full source for this post and the next posts in the series is available\n<a href=\"https://github.com/matthewmazzanti/haskell-regex\">here</a>.</p></section>\n<section><h2 id=\"the-approach\">The Approach</h2><p>While a regex complier is fairly straightforward in the world of compilers, we\nwill be taking a very measured and holistic approach to ensure correctness at\nevery point in the process. We will start with building and testing a regex\n<em>interpreter</em> rather than a <em>compiler</em> to act as a baseline for the rest of the\ntransformations we build. That way, as we apply more advanced algorithms and\noptimizations, we can be sure that their implementation is correct by comparing\nit to the baseline that we establish here.</p></section>\n<section><h2 id=\"regex-ast\">Regex AST</h2><p>Lets start with a basic regex AST implementation:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Regex</span>\n    <span class=\"token operator\">=</span> <span class=\"token constant\">Empty</span>\n    <span class=\"token operator\">|</span> <span class=\"token constant\">Lit</span> <span class=\"token constant\">Char</span>\n    <span class=\"token operator\">|</span> <span class=\"token constant\">And</span> <span class=\"token constant\">Regex</span> <span class=\"token constant\">Regex</span>\n    <span class=\"token operator\">|</span> <span class=\"token constant\">Or</span> <span class=\"token constant\">Regex</span> <span class=\"token constant\">Regex</span>\n    <span class=\"token operator\">|</span> <span class=\"token constant\">Mark</span> <span class=\"token constant\">Regex</span>\n    <span class=\"token operator\">|</span> <span class=\"token constant\">Plus</span> <span class=\"token constant\">Regex</span>\n    <span class=\"token operator\">|</span> <span class=\"token constant\">Star</span> <span class=\"token constant\">Regex</span>\n    <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Show</span></code></pre></div><p>An interesting note about this data type is that any construction with it is a\nvalid regex. Perhaps not a sane regex, but a valid one nonetheless. This is in\nline with the standard Haskell practice of making <em>illegal types\nunrepresentable</em> - there's no way to get an invalid regex here, simplifying the\ntesting code we will write later.</p><p>Lets take a look at some example regex would look like in this data type:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- /abc/</span>\n<span class=\"token constant\">And</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> '<span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- /a|b/</span>\n<span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- /a*|b+/</span>\n<span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div><p>While its a little verbose, its clear that any standard regex you can write can\nbe represented in this framework, which is a good starting point. We will be\nforegoing writing a parsing frontend for this AST for the time being since I am\nprimarily interested in providing a regex implementation as a first pass here.</p></section>\n<section><h2 id=\"simple-ast-interpretation\">Simple AST Interpretation</h2><p>With this data-type in hand, the next order of business is to build a reference\nmatcher implementation:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">match</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">match</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">isJust</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">find</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">==</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span>\n\n<span class=\"token hvariable\">matchStream</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span>        <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>          <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">sym</span><span class=\"token operator\">:</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">)</span>  <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">sym</span> <span class=\"token keyword\">then</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>   <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span>'\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>    <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">&lt;></span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span>' <span class=\"token hvariable\">syms</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>      <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>      <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">star</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">$</span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">syms</span>' <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span>\n    <span class=\"token keyword\">if</span> <span class=\"token hvariable\">syms</span>' <span class=\"token operator\">/=</span> <span class=\"token hvariable\">syms</span>\n       <span class=\"token keyword\">then</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">star</span> <span class=\"token hvariable\">syms</span>'\n       <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></code></pre></div><p>Theres a lot going on here, so lets break this down and take a closer look at\neach of the component parts.</p><h3 id=\"the-match-function\">The <code class=\"language-text\">match</code> function</h3><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">match</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">match</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">isJust</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">find</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">==</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span></code></pre></div><p>The primary match function returns whether or not a given regex and string\nactually produce a full match. The bulk of the work is done in the <code class=\"language-text\">matchStream</code>\nfunction, which produces a list of possible remainder strings after the regex\nhas done the work of parsing. With that input, all we need to do is scan the\nresulting strings and return <code class=\"language-text\">True</code> if we find an empty one, indicating a match.\n<code class=\"language-haskell\"><span class=\"token hvariable\">isJust</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">find</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">==</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></code> does this, searching through this list to find the\nfirst instance of an empty string, indicating that the regex has parsed and\naccepted the entire input.</p><p>This is also an instance of taking advantage of Haskell's lazy evaluation. In\nstrict languages, the <code class=\"language-text\">matchStream</code> would have to eagerly calculate all possible\nparses of the string with the regex, and return a massive list to be searched\nthrough. Therefore, this function would more likely be written as a loop that\nevaluates different options and returns whether a full match is found. However,\nwith lazy evaluation, this list is calculated on-the-fly as we try to find the\nempty string. This allows us to have a nice separation of concerns in our\nimplementation, one function to parse strings and recurse, and another to\nanalyze that input for values we care about. All together this leads to a\ncleaner, more declarative, implementation without the performance overhead this\nwould lead to in strict languages.</p><h3 id=\"simple-cases\">Simple Cases</h3><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span>   <span class=\"token hvariable\">syms</span>       <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span>   <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>         <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>   <span class=\"token punctuation\">(</span><span class=\"token hvariable\">sym</span><span class=\"token operator\">:</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">sym</span> <span class=\"token keyword\">then</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span>       <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span>     <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">&lt;></span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span>' <span class=\"token hvariable\">syms</span></code></pre></div><p>If you're not familiar, <code class=\"language-text\">&lt;&gt;</code> is just list concatenation, and is a more generic\nversion of <code class=\"language-text\">++</code>, E.G.:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">++</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span></code></pre></div><p>As previously noted, <code class=\"language-text\">matchStream</code> takes the regex and the input string and\nreturns a list of possible parses of the string. The basic cases here are fairly\nstraightforward: </p><ul>\n<li><code class=\"language-text\">Empty</code> simply returns a singleton list of the input string.</li>\n<li><code class=\"language-text\">Lit</code> requires that the string be non-empty, and if so, advances the input one\ncharacter. In all other cases it fails and terminates this branch of the\nparse.</li>\n<li><code class=\"language-text\">Mark</code> provides two choices: either the result of matching the expression, or\nthe original stream if we skip the regex.</li>\n<li><code class=\"language-text\">Or</code> just combines the lists produced by the first regex with those of the\nsecond, with the same starting strings as the input.</li>\n</ul><h3 id=\"and-operator\"><code class=\"language-text\">And</code> Operator</h3><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span>'</code></pre></div><p>In the case of the <code class=\"language-text\">And</code> regex we take advantage of the <code class=\"language-text\">&gt;&gt;=</code> (pronounced\n\"bind\") function defined for Lists. This function has type</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">>>=</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">]</span></code></pre></div><p>It takes a list, and a function to produce a list for each value in the list\nvalues, and produces a single new list of all options. This allows us to\ndescribe compounding actions that may produce multiple results, or none at all,\nin a very succinct way. In practice (note: <code class=\"language-ghci\">λ<span class=\"token operator\">=</span></code> is my prompt for ghci,\nthe Haskell interpreter/repl):</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token keyword\">let</span> <span class=\"token hvariable\">rep</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">i</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token operator\">..</span><span class=\"token hvariable\">i</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">rep</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">rep</span> <span class=\"token number\">2</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">rep</span> <span class=\"token number\">4</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token operator\">..</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">rep</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token operator\">..</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">rep</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">rep</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span></code></pre></div><p>We start with a simple function <code class=\"language-text\">rep</code> which, for each value in the list,\nproduces a new list of 1 to <code class=\"language-text\">i</code>. By binding <code class=\"language-text\">rep</code> together multiple times, we\nproduce a single list which is a combination of all of these choices.  We can\nalso terminate a path, as in the case of 0, by returning an empty list.\nRepeating this process again tends to have a multiplicative effect, with each\nlist exponentially longer than the last as the possible choices build up.</p><p>In the case of <code class=\"language-text\">matchStream</code>, this behavior is exactly what we want: All\npossible parses of the first sub-regex should be fed to all parses of the second\nsub-regex, resulting in a list of all possible parses for the combined\noperators. Once again, by example:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token comment\">-- /a?/</span>\n<span class=\"token prompt\">λ= </span><span class=\"token keyword\">let</span> <span class=\"token hvariable\">mark</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">mark</span> <span class=\"token string\">\"a\"</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">-- /a?a?/</span>\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">mark</span> <span class=\"token hvariable\">mark</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"aa\"</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">mark</span> <span class=\"token hvariable\">mark</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"a\"</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">]</span></code></pre></div><p>The most interesting case here is where <code class=\"language-text\">And mark mark</code> is matched against <code class=\"language-text\">&quot;a&quot;</code>\nproducing three choices: </p><ul>\n<li>The first <code class=\"language-text\">Mark</code> matching and the second <code class=\"language-text\">Mark</code> getting skipped.</li>\n<li>The first <code class=\"language-text\">Mark</code> getting skipped and the second <code class=\"language-text\">Mark</code> matching.</li>\n<li>Both <code class=\"language-text\">Marks</code> getting skipped.</li>\n<li>Both <code class=\"language-text\">Marks</code> matching. This choice gets culled, as it causes the second\nliteral to fail and produce <code class=\"language-text\">[]</code>.</li>\n</ul><h3 id=\"the-star-operator\">The <code class=\"language-text\">Star</code> Operator</h3><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">star</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">$</span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">syms</span>' <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span>\n    <span class=\"token keyword\">if</span> <span class=\"token hvariable\">syms</span>' <span class=\"token operator\">/=</span> <span class=\"token hvariable\">syms</span>\n       <span class=\"token keyword\">then</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">star</span> <span class=\"token hvariable\">syms</span>'\n       <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></code></pre></div><p>The <code class=\"language-text\">Star</code> operator is the most complex of the lot, and the only one to take\nadvantage of <code class=\"language-text\">do</code> notation. Lets break it down further.</p><p>We start with <code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code>. This leverages\n<a href=\"https://wiki.haskell.org/Infix_operator\">infix</a> and\n<a href=\"https://wiki.haskell.org/Currying\">curried</a> functions at the same time. It\ndescribes appending the unadvanced string to the rest of the strings produced by\nthe <code class=\"language-text\">Star</code> operator.</p><p>Next is the do notation which is a bit trickier. We bind the result of matching\nthe string to a new variable <code class=\"language-text\">syms&#39;</code>, and check that <code class=\"language-text\">syms&#39;</code> is distinct from\nthe original <code class=\"language-text\">syms</code> variable. This is needed as otherwise if the <code class=\"language-text\">re</code> operator\nmatched no symbols, then we land in an infinite loop of matching no symbols as\nwe recurse. If our <code class=\"language-text\">syms&#39;</code> variable is different we recurse, otherwise\nterminating.</p><p>An example:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"aaa\"</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aaa\"</span><span class=\"token punctuation\">]</span></code></pre></div><p>From this example you can see the resulting parses, in priority order. The first\ncase is a full match- the entire input stream is consumed. From there, we\nbacktrack adding another <code class=\"language-text\">&#39;a&#39;</code> char back into the stream so that other operators\ncan match if needed.</p><h3 id=\"the-plus-operator\">The <code class=\"language-text\">Plus</code> Operator</h3><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span></code></pre></div><p>The <code class=\"language-text\">Plus</code> operator leans on the <code class=\"language-text\">Star</code> operator, since they are nearly the\nsame, but imposes that the regex match at least once before repeating the match\nin the same manner as the <code class=\"language-text\">And</code> operator.</p></section>\n<section><h2 id=\"testing-the-implementation\">Testing the implementation</h2><p>So far we've defined a simple interpreter, but done nothing to ensure that it\nworks! Lets lay down some basic sanity tests:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"a\"</span>\n<span class=\"token constant\">True</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"aa\"</span>\n<span class=\"token constant\">False</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"ab\"</span> \n<span class=\"token constant\">True</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"a\"</span>\n<span class=\"token constant\">True</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"b\"</span>\n<span class=\"token constant\">True</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"aaa\"</span> \n<span class=\"token constant\">True</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"\"</span>\n<span class=\"token constant\">False</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"aaa\"</span>\n<span class=\"token constant\">True</span></code></pre></div><p>Having to think up test cases for every relevant combination of regex and string\nand test them one at a time gets old pretty quickly, at least for me. Luckily,\nas previously mentioned, any data that can be represented by the <code class=\"language-text\">Regex</code> type is\na valid regex, perhaps we can use that to remove some of the repetitiveness\nhere?</p><h3 id=\"quickcheck-property-testing\">QuickCheck Property Testing</h3><p>Enter QuickCheck, a library to automate the testing of code through random test\ncase generation. It provides facilities for generating random data that can be\nfed into your implementation, and then checks that properties that you define\nfor that implementation always hold. If they do not, QuickCheck gives you a\ncounter example to debug. When your input data is complex and you need lots of\ntest cases to ensure everything works, QuickCheck is significantly easier to use\nthan specifying test cases and their results one at a time.</p><p>The first thing we have to do is define an <code class=\"language-text\">Arbitrary</code> instance for our regex\ndata type so that we can generate random regex to test against. This can be\nautomated with Haskell's generic data types, however I've elected to do this\nmanually to get a better feel for the internal workings:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Arbitrary</span> <span class=\"token constant\">Regex</span> <span class=\"token keyword\">where</span>\n  <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">sized</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">genRegex</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">where</span>\n      <span class=\"token hvariable\">genRegex</span> <span class=\"token hvariable\">depth</span> <span class=\"token hvariable\">size</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">frequency</span>\n          <span class=\"token punctuation\">[</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">depth</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Lit</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">arbitraryASCIIChar</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">depth</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">pure</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">size</span><span class=\"token punctuation\">,</span>  <span class=\"token hvariable\">genTwo</span> <span class=\"token constant\">And</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">size</span><span class=\"token punctuation\">,</span>  <span class=\"token hvariable\">genTwo</span> <span class=\"token constant\">Or</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">size</span><span class=\"token punctuation\">,</span>  <span class=\"token hvariable\">genOne</span> <span class=\"token constant\">Mark</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">size</span><span class=\"token punctuation\">,</span>  <span class=\"token hvariable\">genOne</span> <span class=\"token constant\">Star</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">size</span><span class=\"token punctuation\">,</span>  <span class=\"token hvariable\">genOne</span> <span class=\"token constant\">Plus</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">where</span> <span class=\"token hvariable\">genRegex</span>' <span class=\"token operator\">=</span> <span class=\"token hvariable\">genRegex</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">depth</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">size</span>\n              <span class=\"token hvariable\">genOne</span> <span class=\"token hvariable\">fn</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">fn</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">genRegex</span>'\n              <span class=\"token hvariable\">genTwo</span> <span class=\"token hvariable\">fn</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">fn</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">genRegex</span>' <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">genRegex</span>'</code></pre></div><p>Once again, theres a lot going on here so lets break it down.</p><h3 id=\"size-and-frequency\">Size and Frequency</h3><p>The first thing to note is the <code class=\"language-text\">size</code> parameter of <code class=\"language-text\">genRegex</code> and <code class=\"language-text\">sized</code>\nfunction used to call <code class=\"language-text\">genRegex</code> at the top level. We use the size parameter to\nroughly tune the final size of the regex, so that in general as the size param\ngoes up, the average size of the regex increases. QuickCheck increases the\n<code class=\"language-text\">size</code> parameter as it tests more cases, so that it can start with simple cases\nand move on to more complex ones.</p><p>This size parameter is used in the <code class=\"language-text\">frequency</code> function to bias the generation\nof our data. To explain further, lets start with the simpler <code class=\"language-text\">oneof</code> function.\nUsing <code class=\"language-text\">oneof</code> we can build a simple boolean generator as follows:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token keyword\">let</span> <span class=\"token hvariable\">boolGen</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">oneof</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">pure</span> <span class=\"token constant\">True</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">pure</span> <span class=\"token constant\">False</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">sized</span> <span class=\"token number\">10</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">listOf</span> <span class=\"token hvariable\">boolGen</span>\n<span class=\"token punctuation\">[</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">False</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">False</span><span class=\"token punctuation\">,</span><span class=\"token constant\">False</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">False</span><span class=\"token punctuation\">,</span><span class=\"token constant\">False</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">]</span></code></pre></div><p>Each time <code class=\"language-text\">generate</code> is called on this generator it chooses, with equal\nprobability, an item in the list and returns it. Useful, but often you need more\ncontrol, which is where the  <code class=\"language-text\">frequency</code> function comes in. <code class=\"language-text\">frequency</code> allows\nus to bias the generator to produce certain values more often. For example, if\nwe want to produce <code class=\"language-text\">True</code> with a 75% chance and <code class=\"language-text\">False</code> with a 25% chance we\ndefine it as follows:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token keyword\">let</span> <span class=\"token hvariable\">boolGen</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">frequency</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">pure</span> <span class=\"token constant\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">pure</span> <span class=\"token constant\">False</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">sized</span> <span class=\"token number\">10</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">listOf</span> <span class=\"token hvariable\">boolGen</span>\n<span class=\"token punctuation\">[</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">False</span><span class=\"token punctuation\">]</span></code></pre></div><p>As you can see, we are now generating <code class=\"language-text\">True</code> much more often than <code class=\"language-text\">False</code> unlike\nour example with <code class=\"language-text\">oneof</code>.</p><p>In our regex generator, we use the <code class=\"language-text\">frequency</code> function to tune how large the\nresulting structure will be by biasing the generator based on the <code class=\"language-text\">size</code> and\n<code class=\"language-text\">depth</code> parameters. <code class=\"language-text\">size</code> is set by QuickCheck, up to 30.  <code class=\"language-text\">depth</code> is our own\nparameter, starting at 1 and doubling each time we recurse further into the\nregex we are generating. We tie the <code class=\"language-text\">depth</code> parameter to the terminating values\n<code class=\"language-text\">Empty</code> and <code class=\"language-text\">Lit</code> so that as our generator recurses further there is a greater\nand greater chance that generation will stop. We pass <code class=\"language-text\">size</code> into the rest of\nthe parameters, giving us a baseline probability for continuing generation and\nallowing us to make larger structures. As <code class=\"language-text\">size</code> grows, it becomes more likely\nthat the generated regex will recurse deeper to the point where <code class=\"language-text\">depth</code> gets big\nenough to overcome it.</p><p>Lets see this in action:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">resize</span> <span class=\"token number\">1</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">Regex</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">resize</span> <span class=\"token number\">1</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">Regex</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'0'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">resize</span> <span class=\"token number\">10</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">Regex</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">resize</span> <span class=\"token number\">10</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">Regex</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">Or</span>\n  <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span>\n    <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span>\n      <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token constant\">Empty</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">':'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token constant\">Empty</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span>\n    <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div><p>As you can see from these examples, small size values tend to build small\nstructures, whereas larger size values tend to build larger values. Exactly what\nwe need to build a good <code class=\"language-text\">arbitrary</code>!</p><h3 id=\"generating-random-strings\">Generating Random Strings</h3><p>Everything we've done thus far is interesting, however we're still missing the\ncritical piece to testing the <code class=\"language-text\">match</code> implementation: a <code class=\"language-text\">String</code> to match\nagainst! Naïvely, we could just use the <code class=\"language-text\">Arbitrary</code> instance on <code class=\"language-text\">String</code>\nprovided by QuickCheck to generate a random string of random length, however\nthis poses a couple of problems:</p><ul>\n<li>We won't know if a randomly generated string <em>should</em> match, so we can't\ndecide whether the return value of <code class=\"language-text\">match</code> is valid or not.</li>\n<li>The arbitrary instance for <code class=\"language-text\">String</code> will generate strings that are too random.\nThe vast majority of these strings will have nothing to do with our regex, and\nwill not match. This means churning through a lot of data to find cases that\ndo match, increasing the length of our testing process.</li>\n</ul><p>We need to be able to generate random strings that <em>should always</em> match the\ngiven regex, in order to test that our implementation hasn't missed anything.\nThankfully computer science has already thought of this: grammars, the class of\nmathematical objects that regex are a part of, can be used to both match strings\nas well as generate them.</p><p>What we need to do is to build a function of type</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">genString</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">String</span></code></pre></div><p>This would allow us to build a generator that only creates valid strings of a\ngiven <code class=\"language-text\">Regex</code>, nicely solving the problems described above. My implementation\nlooks like this:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">genString</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span>        <span class=\"token operator\">=</span> <span class=\"token hvariable\">pure</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>        <span class=\"token operator\">=</span> <span class=\"token hvariable\">pure</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>   <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span> <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span>'\n<span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>    <span class=\"token operator\">=</span> <span class=\"token hvariable\">oneof</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>      <span class=\"token operator\">=</span> <span class=\"token hvariable\">oneof</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">pure</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>      <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span> <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">star</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">oneof</span>\n    <span class=\"token punctuation\">[</span> <span class=\"token hvariable\">pure</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span> <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">star</span>\n    <span class=\"token punctuation\">]</span></code></pre></div><p>This function is effectively the inverse of the <code class=\"language-text\">match</code> function, generating\nvalues that should always match the given regex fragment and recursing to\ngenerate more of the string from more of the regex. Lets see it in action:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">listOf</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"bb\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"bbb\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aab\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">listOf</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"abaababa\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"abaa\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aba\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aababa\"</span><span class=\"token punctuation\">]</span></code></pre></div><h3 id=\"bringing-it-all-together\">Bringing it all Together</h3><p>With the ability go generate arbitrary regex and valid strings from those regex,\nwe can now build the core test function:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">test</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Property</span>\n<span class=\"token hvariable\">test</span> <span class=\"token hvariable\">re</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">forAll</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">match</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span></code></pre></div><p>Here we take advantage of the <code class=\"language-text\">forAll</code> function from QuickCheck. This allows us\nto generate a random string value for the <code class=\"language-text\">match</code> function, while still tying it\nto the regex that we are testing.</p><p>To run the test we just pass it into the <code class=\"language-text\">quickCheck</code> function:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">quickCheck</span> <span class=\"token hvariable\">test</span>\n<span class=\"token operator\">+++</span> <span class=\"token constant\">OK</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">passed</span> <span class=\"token number\">100</span> <span class=\"token hvariable\">tests</span><span class=\"token punctuation\">.</span></code></pre></div><p>Now at the time of writing, I have already fixed the bugs associated with this\nimplementation, so we don't get to see QuickCheck in action giving a\ncounterexample. Lets intentionally introduce a bug in the <code class=\"language-text\">Mark</code> case and see if\nQuickCheck can find it.</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">matchStream</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span>        <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>          <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">sym</span><span class=\"token operator\">:</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">)</span>  <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">sym</span> <span class=\"token keyword\">then</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>   <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span>'\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>    <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">&lt;></span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span>' <span class=\"token hvariable\">syms</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>      <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token comment\">-- &lt;> [syms]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>      <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">star</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">$</span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">syms</span>' <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span>\n    <span class=\"token keyword\">if</span> <span class=\"token hvariable\">syms</span>' <span class=\"token operator\">/=</span> <span class=\"token hvariable\">syms</span>\n       <span class=\"token keyword\">then</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">star</span> <span class=\"token hvariable\">syms</span>'\n       <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></code></pre></div><p>Running QuickCheck again:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">quickCheck</span> <span class=\"token hvariable\">test</span>\n<span class=\"token operator\">***</span> <span class=\"token constant\">Failed</span><span class=\"token operator\">!</span> <span class=\"token constant\">Falsified</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">after</span> <span class=\"token number\">8</span> <span class=\"token hvariable\">tests</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>  \n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'L'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">\"\"</span></code></pre></div><p>So it found the bug, and gave us a counterexample.  This is great, but the\ncounterexample is long and difficult to follow, especially if you don't know\nwhat the issue really was. This is where QuickCheck's <em>shrinking</em> capability\ncomes in: when the test function finds a counterexample, it then runs the\n<code class=\"language-text\">shrink</code> function to try out different variations of smaller inputs so that it\ncan give you better results.</p><p>Lets implement the shrink function for our <code class=\"language-text\">Arbitrary</code> instance:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Arbitrary</span> <span class=\"token constant\">Regex</span> <span class=\"token keyword\">where</span>\n  <span class=\"token operator\">...</span>\n\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span>      <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span>      <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrinkTwo</span> <span class=\"token constant\">And</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>  <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrinkTwo</span> <span class=\"token constant\">Or</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>    <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrinkOne</span> <span class=\"token constant\">Mark</span> <span class=\"token hvariable\">re</span>\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>    <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrinkOne</span> <span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span>\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>    <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrinkOne</span> <span class=\"token constant\">Plus</span> <span class=\"token hvariable\">re</span>\n\n\n<span class=\"token hvariable\">shrinkOne</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Arbitrary</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">shrinkOne</span> <span class=\"token hvariable\">fn</span> <span class=\"token hvariable\">re</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">join</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">re</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">fn</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">where</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrink</span> <span class=\"token hvariable\">re</span>\n\n\n<span class=\"token hvariable\">shrinkTwo</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Arbitrary</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">shrinkTwo</span> <span class=\"token hvariable\">fn</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>' <span class=\"token operator\">=</span> <span class=\"token hvariable\">join</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">re</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">fn</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">where</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrink</span> <span class=\"token hvariable\">re</span>\n        <span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrink</span> <span class=\"token hvariable\">re</span>'</code></pre></div><p>The shrink function for this instance is of type <code class=\"language-haskell\"><span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Regex</span><span class=\"token punctuation\">]</span></code>, the\nidea being that for a given regex, we return a list of smaller values that\nQuickCheck can test against to find a better counterexample.</p><p>The base cases are <code class=\"language-text\">Lit</code> and <code class=\"language-text\">Empty</code>, where we return empty lists, since these\nare terminating values that can't be shrunk any further.</p><p>I also defined the <code class=\"language-text\">shrinkOne</code> function that lets us shrink a regex with a\nsingle argument constructor, and <code class=\"language-text\">shrinkTwo</code> that does the same with a\ntwo-argument constructor. In order, these return:</p><ul>\n<li>All the shrinks of the inner regex.</li>\n<li>The original inner regex.</li>\n<li>All the shrinks of the inner regex, within the original constructor.</li>\n</ul><p>By example:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">[</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">[</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span></code></pre></div><p>As you can see, when given a regex, the shrink function will generate all\ncombinations of sub-regex so that we can test against them.</p><p>With shrink defined, lets test the bugged version one more time to see if our\nerror output has improved:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">quickCheck</span> <span class=\"token hvariable\">test</span>\n<span class=\"token operator\">***</span> <span class=\"token constant\">Failed</span><span class=\"token operator\">!</span> <span class=\"token constant\">Falsified</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">after</span> <span class=\"token number\">9</span> <span class=\"token hvariable\">tests</span> <span class=\"token builtin\">and</span> <span class=\"token number\">1</span> <span class=\"token hvariable\">shrink</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'S'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">\"\"</span></code></pre></div><p>This is certainly an improvement, but is still more complex than we'd hope - we\nshould only see a single <code class=\"language-text\">Mark</code> in our error output.</p><p>Taking a look at the verbose output gives us a hint to the issue:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">quickCheck</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">verbose</span> <span class=\"token hvariable\">test</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">...</span>\n\n<span class=\"token constant\">Passed</span><span class=\"token operator\">:</span>\n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'S'</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">\"S\"</span>\n\n<span class=\"token operator\">***</span> <span class=\"token constant\">Failed</span><span class=\"token operator\">!</span> <span class=\"token constant\">Falsified</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">after</span> <span class=\"token number\">9</span> <span class=\"token hvariable\">tests</span> <span class=\"token builtin\">and</span> <span class=\"token number\">1</span> <span class=\"token hvariable\">shrink</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'S'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">\"\"</span></code></pre></div><p>When QuickCheck runs the tests again, its generating a single random string for\nthe input to the regex. As we can see you can get unlucky and generate a\nmatching string for the regex. In our example our bugged input should be <code class=\"language-text\">&quot;&quot;</code>,\nhowever for the <code class=\"language-text\">Mark (Lit &#39;S&#39;)</code> shrink the only input generated was <code class=\"language-text\">&quot;S&quot;</code>. To\nimprove the odds of getting a minimal counterexample, we can simply increase the\nnumber of strings generated and passed to test our regex:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">test</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Property</span>\n<span class=\"token hvariable\">test</span> <span class=\"token hvariable\">re</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">conjoin</span> <span class=\"token operator\">$</span> <span class=\"token builtin\">replicate</span> <span class=\"token number\">10</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">forAll</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">match</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span></code></pre></div><p>Now instead of testing a single random input string, we generate 10. This makes\nit significantly less likely that we will just skip over failing counterexamples\nby generating the wrong string.</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">quickCheck</span> <span class=\"token hvariable\">test</span>\n<span class=\"token operator\">***</span> <span class=\"token constant\">Failed</span><span class=\"token operator\">!</span> <span class=\"token constant\">Falsified</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">after</span> <span class=\"token number\">17</span> <span class=\"token hvariable\">tests</span> <span class=\"token builtin\">and</span> <span class=\"token number\">1</span> <span class=\"token hvariable\">shrink</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'R'</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">\"\"</span></code></pre></div><p>Much better!</p></section>\n<section><h2 id=\"wrapping-up\">Wrapping Up</h2><p>So far, we've defined a basic regex syntax tree and interpreter for it, and\nproven that it works with QuickCheck. This is a good first step, and if your\ngoal is just to define a working regex engine then this is all you need!</p><p>However there is a problem with this implementation: in a worst case scenario,\nthe runtime is exponential, as it has to backtrack through all possible\ncombinations of how the regex could match the string. This means that it becomes easy to build degenerate\nregex that can take far longer than needed to match strings, since they get\ncaught up backtracking trying to find a match.</p><p>Fortunately, comp-sci comes to the rescue again! By doing\n<a href=\"https://en.wikipedia.org/wiki/Thompson%27s_construction\">Thompson's construction</a>\non our regex, we can turn it into a\n<a href=\"https://en.wikipedia.org/wiki/Deterministic_finite_automaton\">deterministic finite automation</a>\nwith a linear runtime. I will explore doing this construction and verifying it\nwith the testing infrastructure we have set up here in the next posts of this\nseries.</p></section>","frontmatter":{"title":"Compiling Regex in Haskell, Part 1","subtitle":"Building and Testing a Regex Interpreter","date":"Oct 27, 2020"}}},"pageContext":{"slug":"blog/haskell-regex-1/"}},"staticQueryHashes":[]}