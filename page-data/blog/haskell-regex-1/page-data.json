{"componentChunkName":"component---src-components-blog-tplt-js","path":"/blog/haskell-regex-1/","result":{"data":{"markdownRemark":{"html":"<section><p>The full source for this post and the next posts in the series is available\n<a href=\"https://github.com/matthewmazzanti/haskell-regex\">here</a>.</p></section>\n<section><h2 id=\"regex-ast\">Regex AST</h2><p>The first order of business is to get a basic data-type for the regex laid down.\nMy implementation looks as follows:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Regex</span>\n    <span class=\"token operator\">=</span> <span class=\"token constant\">Empty</span>\n    <span class=\"token operator\">|</span> <span class=\"token constant\">Lit</span> <span class=\"token constant\">Char</span>\n    <span class=\"token operator\">|</span> <span class=\"token constant\">And</span> <span class=\"token constant\">Regex</span> <span class=\"token constant\">Regex</span>\n    <span class=\"token operator\">|</span> <span class=\"token constant\">Or</span> <span class=\"token constant\">Regex</span> <span class=\"token constant\">Regex</span>\n    <span class=\"token operator\">|</span> <span class=\"token constant\">Mark</span> <span class=\"token constant\">Regex</span>\n    <span class=\"token operator\">|</span> <span class=\"token constant\">Plus</span> <span class=\"token constant\">Regex</span>\n    <span class=\"token operator\">|</span> <span class=\"token constant\">Star</span> <span class=\"token constant\">Regex</span>\n    <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Show</span></code></pre></div><p>A fact that I will be using later to test the implementation is that any\nconstruction using this data type is a valid regex. Perhaps not a sane regex,\nbut a valid one nonetheless. This is in line with the standard Haskell practice\nof making \"illegal types unrepresentable\" - there's no way to get an invalid\nregex here, simplifying the code I need to write later.</p><p>Lets take a look at what some simple regex would look like in this data type:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- /abc/</span>\n<span class=\"token constant\">And</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> '<span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- /a|b/</span>\n<span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- /a*|b+/</span>\n<span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div><p>While its a little verbose, its clear that any standard regex you can write can\nbe represented in this framework, which is a good starting point.</p></section>\n<section><h2 id=\"simple-ast-interpretation\">Simple AST Interpretation</h2><p>The next order of business is to build a reference matcher implementation. As\nwe compile the regex to different forms, we can compare the results against this\nreference implementation to ensure behavior stays consistent, and that we are\nimproving runtimes. Here is my implementation:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">match</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">match</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">isJust</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">find</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">==</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span>\n\n<span class=\"token hvariable\">matchStream</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span>        <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>          <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">sym</span><span class=\"token operator\">:</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">)</span>  <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">sym</span> <span class=\"token keyword\">then</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>   <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span>'\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>    <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">&lt;></span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span>' <span class=\"token hvariable\">syms</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>      <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>      <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">star</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">$</span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">syms</span>' <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span>\n    <span class=\"token keyword\">if</span> <span class=\"token hvariable\">syms</span>' <span class=\"token operator\">/=</span> <span class=\"token hvariable\">syms</span>\n       <span class=\"token keyword\">then</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">star</span> <span class=\"token hvariable\">syms</span>'\n       <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></code></pre></div><p>Theres a lot going on here, so lets take a closer look at each of the component\nparts.</p><h3 id=\"the-match-function\">The <code class=\"language-text\">match</code> function</h3><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">match</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">match</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">isJust</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">find</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">==</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span></code></pre></div><p>This is the primary match function that returns whether or not the given regex\nand string actually produce a match. The bulk of the work is done in the\n<code class=\"language-text\">matchStream</code> function, which produces a list of possible remainder strings\nafter the regex has done the work of parsing. With that input, all we need to do\nis scan the resulting strings and return <code class=\"language-text\">True</code> if we find an empty one,\nindicating a full match. <code class=\"language-haskell\"><span class=\"token hvariable\">isJust</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">find</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">==</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></code> does this, searching\nthrough this list to find the first instance of an empty string, indicating that\nthe regex has parsed and accepted the entire input.</p><p>This is also an instance of using Haskell's lazy evaluation to our advantage. In\na standard strict language, the <code class=\"language-text\">matchStream</code> would have to eagerly calculate\nall possible parses of the string with the regex, and return a massive list to\nbe searched through. This is not the case in Haskell.  This list is calculated\non-the-fly as we try to find the empty string, meaning that while we wrote this\nfunction in an declarative way, we don't need to worry about the exponential\nsize of the <code class=\"language-text\">matchStream</code> result, except in degenerate cases.</p><h3 id=\"simple-cases\">Simple Cases</h3><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span>   <span class=\"token hvariable\">syms</span>       <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span>   <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>         <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>   <span class=\"token punctuation\">(</span><span class=\"token hvariable\">sym</span><span class=\"token operator\">:</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">sym</span> <span class=\"token keyword\">then</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span>       <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span></code></pre></div><p>As previously noted, <code class=\"language-text\">matchStream</code> takes the regex and the input string and\nreturns a list of possible parses of the string. The basic cases here are fairly\nstraightforward: </p><ul>\n<li><code class=\"language-text\">Empty</code> simply returns a singleton list of the input string.</li>\n<li><code class=\"language-text\">Lit</code> requires that the string be non-empty, and if it is it advances the\ninput one character, failing and terminating the parse in all other cases.</li>\n<li><code class=\"language-text\">Mark</code> provides two choices: either the result of matching the expression, or\nthe original stream if we skip the regex.</li>\n</ul><h3 id=\"and-operator\"><code class=\"language-text\">And</code> Operator</h3><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span>'</code></pre></div><p>In the case of the <code class=\"language-text\">And</code> regex we take advantage of the <code class=\"language-text\">&gt;&gt;=</code> (pronounced\n\"bind\") function defined for Lists. This function has type</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">>>=</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">]</span></code></pre></div><p>It takes a list, and a function to produce a list for each value in the list\nvalues, and produces a single new list of all options. This allows us to\ndescribe compounding actions that may produce multiple results, or none at all,\nin a very succinct way. In practice (note: <code class=\"language-ghci\">λ<span class=\"token operator\">=</span></code> is my prompt for ghci):</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token keyword\">let</span> <span class=\"token hvariable\">rep</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">i</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token operator\">..</span><span class=\"token hvariable\">i</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">rep</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">rep</span> <span class=\"token number\">2</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">rep</span> <span class=\"token number\">4</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token operator\">..</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">rep</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token operator\">..</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">rep</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">rep</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span></code></pre></div><p>We start with a simple function <code class=\"language-text\">rep</code> which, for each value in the list,\nproduces produce a new list of 1 to <code class=\"language-text\">i</code>. By binding <code class=\"language-text\">rep</code> together multiple\ntimes, we produce a single list which is a combination of all of these choices.\nWe can also terminate a path, as in the case of 0, by returning an empty list.\nRepeating this process again tends to have a multiplicative effect, with each\nlist exponentially longer than the last as the possible choices build up.</p><p>In the case of <code class=\"language-text\">matchStream</code>, this behavior is exactly what we want: All\npossible parses of the first sub-regex should be fed to all parses of the second\nsub-regex, resulting in a list of all possible parses for the combined\noperators. Once again, by example:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token comment\">-- /a?/</span>\n<span class=\"token prompt\">λ= </span><span class=\"token keyword\">let</span> <span class=\"token hvariable\">mark</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">mark</span> <span class=\"token string\">\"a\"</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">-- /a?a?/</span>\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">mark</span> <span class=\"token hvariable\">mark</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"aa\"</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">mark</span> <span class=\"token hvariable\">mark</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"a\"</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">]</span></code></pre></div><p>The most interesting case here is where <code class=\"language-text\">And mark mark</code> is matched against <code class=\"language-text\">&quot;a&quot;</code>\nproducing three choices: </p><ul>\n<li>The first <code class=\"language-text\">Mark</code> matching and the second <code class=\"language-text\">Mark</code> getting skipped.</li>\n<li>The first <code class=\"language-text\">Mark</code> getting skipped and the second <code class=\"language-text\">Mark</code> matching.</li>\n<li>Both <code class=\"language-text\">Marks</code> getting skipped.</li>\n<li>Both <code class=\"language-text\">Marks</code> matching. This choice gets culled, as it causes the second\nliteral to fail and produce <code class=\"language-text\">[]</code>.</li>\n</ul><h3 id=\"the-or-operator\">The <code class=\"language-text\">Or</code> Operator</h3><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">&lt;></span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span>' <span class=\"token hvariable\">syms</span></code></pre></div><p>By comparison, the <code class=\"language-text\">Or</code> operator is relatively simple. We just combine the lists\nproduced by the first regex with those of the second, with the same list of\nstrings as the input. If you're not familiar, <code class=\"language-text\">&lt;&gt;</code> is just list concatenation,\nand is a more generic version of <code class=\"language-text\">++</code>, E.G.:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">++</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span></code></pre></div><h3 id=\"the-plus-and-star-operators\">The <code class=\"language-text\">Plus</code> and <code class=\"language-text\">Star</code> Operators</h3><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span></code></pre></div><p>The <code class=\"language-text\">Plus</code> operator leans on the <code class=\"language-text\">Star</code> operator, since they are nearly the\nsame, but imposes that the regex match at least once before repeating the match\nin the same manner as the <code class=\"language-text\">And</code> operator.</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">star</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">$</span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">syms</span>' <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span>\n    <span class=\"token keyword\">if</span> <span class=\"token hvariable\">syms</span>' <span class=\"token operator\">/=</span> <span class=\"token hvariable\">syms</span>\n       <span class=\"token keyword\">then</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">star</span> <span class=\"token hvariable\">syms</span>'\n       <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></code></pre></div><p>The <code class=\"language-text\">Star</code> operator is the most complex of the lot, and the only one to take\nadvantage of <code class=\"language-text\">do</code> notation. Lets break it down further.</p><p>We start with <code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code>. This leverages\n<a href=\"https://wiki.haskell.org/Infix_operator\">infix</a> functions and\n<a href=\"https://wiki.haskell.org/Currying\">curried</a> functions at the same time. It\ndescribes appending the unadvanced string to the rest of the strings produced by\nthe <code class=\"language-text\">Star</code> operator.</p><p>Next is the do notation which is a bit trickier. We bind the result of matching\nthe string to a new variable <code class=\"language-text\">syms&#39;</code>, and check that <code class=\"language-text\">syms&#39;</code> is distinct from\nthe original <code class=\"language-text\">syms</code> variable. This is needed as otherwise if the <code class=\"language-text\">re</code> operator\nmatched no symbols, then we land in an infinite loop of matching no symbols as\nwe recurse. If our <code class=\"language-text\">syms&#39;</code> variable is different we recurse, otherwise\nterminating.</p><p>An example:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"aaa\"</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aaa\"</span><span class=\"token punctuation\">]</span></code></pre></div><p>From this example you can see the resulting parses, in priority order. The first\ncase is a full match- the entire input stream is consumed. From there, we\nbacktrack adding another 'a' literal back into the stream so that other\noperators can match if needed.</p></section>\n<section><h2 id=\"testing-the-implementation\">Testing the implementation</h2><p>So far we've defined a simple interpreter, but done nothing to ensure that it\nworks! Lets lay down some basic sanity tests:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"a\"</span>\n<span class=\"token constant\">True</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"aa\"</span>\n<span class=\"token constant\">False</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"ab\"</span> \n<span class=\"token constant\">True</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"a\"</span>\n<span class=\"token constant\">True</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"b\"</span>\n<span class=\"token constant\">True</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"aaa\"</span> \n<span class=\"token constant\">True</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"\"</span>\n<span class=\"token constant\">False</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">match</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"aaa\"</span>\n<span class=\"token constant\">True</span></code></pre></div><p>Having to think up test cases for everything and test them one at a time, manual\ntesting gets old pretty quickly, at least for me. Luckily, as previously\nmentioned, any data that can be represented by the <code class=\"language-text\">Regex</code> type is a valid\nregex, perhaps we can use that to automatically test our implementation?</p><h3 id=\"quickcheck-property-testing\">QuickCheck Property Testing</h3><p>Enter QuickCheck, a library to automate the testing of code through random test\ncase generation. It provides facilities for generating random data that can be\nfed into your implementation, and then checks that properties of that\nimplementation always hold. If they do not, QuickCheck gives you a counter\nexample to debug. When your input data is complex and you need lots of test\ncases to ensure everything works, QuickCheck is significantly easier to use than\nspecifying test cases and their results by hand.</p><p>The first thing we have to do is define an <code class=\"language-text\">Arbitrary</code> instance for our regex\ndata type so that we can generate random regex to test against. This can be\nautomated with Haskell's generic data types, however I've elected to do this\nmanually to get a better feel for the internal workings:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Arbitrary</span> <span class=\"token constant\">Regex</span> <span class=\"token keyword\">where</span>\n  <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">sized</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">genRegex</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">where</span>\n      <span class=\"token hvariable\">genRegex</span> <span class=\"token hvariable\">depth</span> <span class=\"token hvariable\">size</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">frequency</span>\n          <span class=\"token punctuation\">[</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">depth</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Lit</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">arbitraryASCIIChar</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">depth</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">pure</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">size</span><span class=\"token punctuation\">,</span>  <span class=\"token hvariable\">genTwo</span> <span class=\"token constant\">And</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">size</span><span class=\"token punctuation\">,</span>  <span class=\"token hvariable\">genTwo</span> <span class=\"token constant\">Or</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">size</span><span class=\"token punctuation\">,</span>  <span class=\"token hvariable\">genOne</span> <span class=\"token constant\">Mark</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">size</span><span class=\"token punctuation\">,</span>  <span class=\"token hvariable\">genOne</span> <span class=\"token constant\">Star</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">size</span><span class=\"token punctuation\">,</span>  <span class=\"token hvariable\">genOne</span> <span class=\"token constant\">Plus</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">where</span> <span class=\"token hvariable\">genRegex</span>' <span class=\"token operator\">=</span> <span class=\"token hvariable\">genRegex</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">depth</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">size</span>\n              <span class=\"token hvariable\">genOne</span> <span class=\"token hvariable\">fn</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">fn</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">genRegex</span>'\n              <span class=\"token hvariable\">genTwo</span> <span class=\"token hvariable\">fn</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">fn</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">genRegex</span>' <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">genRegex</span>'</code></pre></div><p>Once again, theres a lot going on here so lets break it down.</p><h3 id=\"size-and-frequency\">Size and Frequency</h3><p>The first thing to note is the <code class=\"language-text\">size</code> parameter and <code class=\"language-text\">sized</code> function. This\nstructure allows QuickCheck to gradually increase the size of generated values\nas it tests more cases, so that it can start with simple cases and move on to\nmore complex ones.</p><p>This size parameter is combined with the <code class=\"language-text\">frequency</code> function to bias the\ngeneration of our data. To explain further, lets start with the simpler <code class=\"language-text\">oneof</code>\nfunction. For example, we can build a simple boolean generator as follows:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token keyword\">let</span> <span class=\"token hvariable\">boolGen</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">oneof</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">pure</span> <span class=\"token constant\">True</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">pure</span> <span class=\"token constant\">False</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">sized</span> <span class=\"token number\">10</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">listOf</span> <span class=\"token hvariable\">boolGen</span>\n<span class=\"token punctuation\">[</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">False</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">False</span><span class=\"token punctuation\">,</span><span class=\"token constant\">False</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">False</span><span class=\"token punctuation\">,</span><span class=\"token constant\">False</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">]</span></code></pre></div><p>This setup builds a very simple generator. Each time <code class=\"language-text\">generate</code> is used to\nproduce a value it chooses, with equal probability, an item in the list and\nreturns it. This leads into the <code class=\"language-text\">frequency</code> function, that allows us to bias\nthe generator to produce certain values more often. For example, if we want to\nproduce <code class=\"language-text\">True</code> with a 75% chance and <code class=\"language-text\">False</code> with a 25% chance we could define\nit as follows:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token keyword\">let</span> <span class=\"token hvariable\">boolGen</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">frequency</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">pure</span> <span class=\"token constant\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">pure</span> <span class=\"token constant\">False</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">sized</span> <span class=\"token number\">10</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">listOf</span> <span class=\"token hvariable\">boolGen</span>\n<span class=\"token punctuation\">[</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token constant\">False</span><span class=\"token punctuation\">]</span></code></pre></div><p>As you can see, we are now generating <code class=\"language-text\">True</code> much more often than <code class=\"language-text\">False</code> unlike\nour example with <code class=\"language-text\">oneof</code>.</p><p>In our regex generator, we use the <code class=\"language-text\">frequency</code> function to tune how large the\nresulting structure will be through the <code class=\"language-text\">size</code> and <code class=\"language-text\">depth</code> parameters. <code class=\"language-text\">size</code> is\nset by QuickCheck, with a default max of 30. <code class=\"language-text\">depth</code> is our own parameter,\nstarting at 1 and doubling each time we recurse further into the regex we are\ngenerating. We tie the <code class=\"language-text\">depth</code> parameter to terminating values - <code class=\"language-text\">Empty</code> and\n<code class=\"language-text\">Lit</code>, so that as our generator recurses further there is a greater and greater\nchance that generation will stop. We pass <code class=\"language-text\">size</code> into the rest of the\nparameters, giving us a baseline probability for continuing generation and\nallowing us to make larger structures. As <code class=\"language-text\">size</code> grows, it becomes more likely\nthat the generated regex will recurse deeper to the point where <code class=\"language-text\">depth</code>\novercomes it.</p><p>Lets see this in action:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">resize</span> <span class=\"token number\">1</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">Regex</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">resize</span> <span class=\"token number\">1</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">Regex</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'0'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">resize</span> <span class=\"token number\">1</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">Regex</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">Mark</span> <span class=\"token constant\">Empty</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">resize</span> <span class=\"token number\">10</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">Regex</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">resize</span> <span class=\"token number\">10</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">Regex</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">Or</span>\n  <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span>\n    <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span>\n      <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token constant\">Empty</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">':'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token constant\">Empty</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span>\n    <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">resize</span> <span class=\"token number\">10</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">Regex</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'e'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div><p>As you can see from these (cherry-picked) examples, small size values tend to\nbuild small structures, whereas larger size values tend to build larger values.\nExactly what we need to build a good <code class=\"language-text\">arbitrary</code>!</p><h3 id=\"generating-random-strings\">Generating Random Strings</h3><p>Everything we've done thus far is interesting, however we're still missing the\ncritical piece to testing the <code class=\"language-text\">match</code> implementation: a <code class=\"language-text\">String</code> to match\nagainst! Naïvely, we could just use the <code class=\"language-text\">Arbitrary</code> instance on <code class=\"language-text\">String</code>\nprovided by QuickCheck, however this poses a couple of problems:</p><ul>\n<li>We won't know if a randomly generated string <em>should</em> match, so we can't\ndecide whether the return value of <code class=\"language-text\">match</code> is valid or not.</li>\n<li>The arbitrary instance for <code class=\"language-text\">String</code> will generate arbitrary strings, the vast\nmajority of which will have nothing to do with our regex, and will thus not\nmatch. This means churning through a lot of data to find cases that do match,\nincreasing the length of our testing process.</li>\n</ul><p>We need to be able to generate random strings that <em>should always</em> match the\ngiven regex, in order to test that our implementation hasn't missed anything.\nThankfully computer science has already thought of this: grammars, the class of\nmathematical objects that regex are a part of, can be used to both match strings\nas well as generate them.</p><p>What we need to do is to build a function of type</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">genString</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">String</span></code></pre></div><p>This would allow us to build a generator that only creates valid strings of a\ngiven <code class=\"language-text\">Regex</code>, nicely solving the problems described above. My implementation\nlooks like this:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">genString</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Gen</span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span>        <span class=\"token operator\">=</span> <span class=\"token hvariable\">pure</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>        <span class=\"token operator\">=</span> <span class=\"token hvariable\">pure</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>   <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span> <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span>'\n<span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>    <span class=\"token operator\">=</span> <span class=\"token hvariable\">oneof</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>      <span class=\"token operator\">=</span> <span class=\"token hvariable\">oneof</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">pure</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>      <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span> <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">star</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">oneof</span>\n    <span class=\"token punctuation\">[</span> <span class=\"token hvariable\">pure</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span> <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">star</span>\n    <span class=\"token punctuation\">]</span></code></pre></div><p>This function is effectively the inverse of the <code class=\"language-text\">match</code> function, generating\nvalues that should always match the given regex fragment and recursing to\ngenerate more of the string from more of the regex. Lets see it in action:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">listOf</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"bb\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"bbb\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aab\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">generate</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">listOf</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">genString</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"abaababa\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"abaa\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aba\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aababa\"</span><span class=\"token punctuation\">]</span></code></pre></div><h3 id=\"bringing-it-all-together\">Bringing it all Together</h3><p>With the ability go generate arbitrary regex and strings from those regex, we\ncan now start testing. </p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">test</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Property</span>\n<span class=\"token hvariable\">test</span> <span class=\"token hvariable\">re</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">forAll</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">match</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span></code></pre></div><p>Here we take advantage of the <code class=\"language-text\">forAll</code> function from QuickCheck. This allows us\nto generate a string value for the <code class=\"language-text\">match</code> functions second parameter, while\nstill tying it to the regex that we are testing.</p><p>To run the test we just pass it into the <code class=\"language-text\">quickCheck</code> function:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">quickCheck</span> <span class=\"token hvariable\">test</span>\n<span class=\"token operator\">+++</span> <span class=\"token constant\">OK</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">passed</span> <span class=\"token number\">100</span> <span class=\"token hvariable\">tests</span><span class=\"token punctuation\">.</span></code></pre></div><p>Now at the time of writing, I have already fixed the bugs associated with this\nimplementation, so we don't get to see QuickCheck in action giving a\ncounterexample. Lets intentionally introduce a bug and see if QuickCheck can\nfind it.</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">matchStream</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span>        <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>          <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">sym</span><span class=\"token operator\">:</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">)</span>  <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">sym</span> <span class=\"token keyword\">then</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>   <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span>'\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>    <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">&lt;></span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span>' <span class=\"token hvariable\">syms</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>      <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token comment\">-- &lt;> [syms]</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>      <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">>>=</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">star</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">syms</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">syms</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">$</span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">syms</span>' <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">syms</span>\n    <span class=\"token keyword\">if</span> <span class=\"token hvariable\">syms</span>' <span class=\"token operator\">/=</span> <span class=\"token hvariable\">syms</span>\n       <span class=\"token keyword\">then</span> <span class=\"token hvariable\">matchStream</span> <span class=\"token hvariable\">star</span> <span class=\"token hvariable\">syms</span>'\n       <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></code></pre></div><p>Running QuickCheck again:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">quickCheck</span> <span class=\"token hvariable\">test</span>\n<span class=\"token operator\">***</span> <span class=\"token constant\">Failed</span><span class=\"token operator\">!</span> <span class=\"token constant\">Falsified</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">after</span> <span class=\"token number\">8</span> <span class=\"token hvariable\">tests</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>  \n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'L'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">\"\"</span></code></pre></div><p>This time we see that the test has failed and given us a counterexample regex\nand associated string. This is great, but the counterexample is long and\ndifficult to follow, especially if you didn't know where the issue really was.\nThis is where QuickCheck's shrinking capability comes in: when the test function\nfinds a counterexample, it then runs the <code class=\"language-text\">shrink</code> function to try out different\nvariations of smaller inputs so that it can give you better results.</p><p>Lets implement the shrink function for our <code class=\"language-text\">Arbitrary</code> instance:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Arbitrary</span> <span class=\"token constant\">Regex</span> <span class=\"token keyword\">where</span>\n  <span class=\"token hvariable\">arbitrary</span> <span class=\"token operator\">=</span> <span class=\"token operator\">...</span>\n\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span>      <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Empty</span><span class=\"token punctuation\">)</span>      <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">And</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrinkTwo</span> <span class=\"token constant\">And</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">)</span>  <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrinkTwo</span> <span class=\"token constant\">Or</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>'\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>    <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrinkOne</span> <span class=\"token constant\">Mark</span> <span class=\"token hvariable\">re</span>\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>    <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrinkOne</span> <span class=\"token constant\">Star</span> <span class=\"token hvariable\">re</span>\n  <span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span>    <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrinkOne</span> <span class=\"token constant\">Plus</span> <span class=\"token hvariable\">re</span>\n\n\n<span class=\"token hvariable\">shrinkOne</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Arbitrary</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">shrinkOne</span> <span class=\"token hvariable\">fn</span> <span class=\"token hvariable\">re</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">join</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">re</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">fn</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">where</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrink</span> <span class=\"token hvariable\">re</span>\n\n\n<span class=\"token hvariable\">shrinkTwo</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Arbitrary</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">shrinkTwo</span> <span class=\"token hvariable\">fn</span> <span class=\"token hvariable\">re</span> <span class=\"token hvariable\">re</span>' <span class=\"token operator\">=</span> <span class=\"token hvariable\">join</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">re</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">re</span>'<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">fn</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">where</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrink</span> <span class=\"token hvariable\">re</span>\n        <span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">shrink</span> <span class=\"token hvariable\">re</span>'</code></pre></div><p>The shrink function for this instance is of type <code class=\"language-haskell\"><span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Regex</span><span class=\"token punctuation\">]</span></code>, the\nidea being that for a given regex, we return a list of smaller values that\nQuickCheck can test against to find a better counterexample.</p><p>From there, our base cases are <code class=\"language-text\">Lit</code> and <code class=\"language-text\">Empty</code>, where we return empty lists,\nsince these are terminating values that can't be shrunk any further.</p><p>I also defined the <code class=\"language-text\">shrinkOne</code> function that lets us shrink a regex with a\nsingle argument constructor. In order, it returns:</p><ul>\n<li>All the shrinks of the inner regex.</li>\n<li>The original inner regex.</li>\n<li>All the shrinks of the inner regex, within the original constructor.</li>\n</ul><p>By example:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">[</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Star</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token prompt\">λ= </span><span class=\"token hvariable\">shrink</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Or</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">[</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Plus</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span></code></pre></div><p>As you can see, when given a regex, the shrink function will try out all\ncombinations of sub-regex so that we can test against them.</p><p>With shrink defined, lets test the bugged version one more time to see if our\nerror output has improved.</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">quickCheck</span> <span class=\"token hvariable\">test</span>\n<span class=\"token operator\">***</span> <span class=\"token constant\">Failed</span><span class=\"token operator\">!</span> <span class=\"token constant\">Falsified</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">after</span> <span class=\"token number\">9</span> <span class=\"token hvariable\">tests</span> <span class=\"token builtin\">and</span> <span class=\"token number\">1</span> <span class=\"token hvariable\">shrink</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'S'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">\"\"</span></code></pre></div><p>This is certainly and improvement, but is still more complex than we'd hope - we\nshould only see a single <code class=\"language-text\">Mark</code> in our error output.</p><p>Well taking a look at the verbose output gives us a hint to the issue:</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">quickCheck</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">verbose</span> <span class=\"token hvariable\">test</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">...</span>\n\n<span class=\"token constant\">Passed</span><span class=\"token operator\">:</span>\n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'S'</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">\"S\"</span>\n\n<span class=\"token operator\">***</span> <span class=\"token constant\">Failed</span><span class=\"token operator\">!</span> <span class=\"token constant\">Falsified</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">after</span> <span class=\"token number\">9</span> <span class=\"token hvariable\">tests</span> <span class=\"token builtin\">and</span> <span class=\"token number\">1</span> <span class=\"token hvariable\">shrink</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'S'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">\"\"</span></code></pre></div><p>When QuickCheck runs the tests again, its generating a single random string for\nthe input to the regex. As we can see you can get unlucky and generate a\nmatching string for the regex. In our example our bugged input should be <code class=\"language-text\">&quot;&quot;</code>,\nhowever for the <code class=\"language-text\">Mark (Lit &#39;S&#39;)</code> case the only generated input was <code class=\"language-text\">&quot;S&quot;</code>. To\nimprove this and increase the odds of getting a minimal counterexample, we can\nsimply increase the number of strings generated to test our regex:</p><div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">test</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Regex</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Property</span>\n<span class=\"token hvariable\">test</span> <span class=\"token hvariable\">re</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">conjoin</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">replicate</span> <span class=\"token number\">10</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">forAll</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">genString</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">match</span> <span class=\"token hvariable\">re</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div><p>Now instead of testing a single random input string, we generate 10. This makes\nit significantly less likely that we will just skip over failing counterexamples\nby generating the wrong string.</p><div class=\"gatsby-highlight\" data-language=\"ghci\"><pre class=\"language-ghci\"><code class=\"language-ghci\"><span class=\"token prompt\">λ= </span><span class=\"token hvariable\">quickCheck</span> <span class=\"token hvariable\">test</span>\n<span class=\"token operator\">***</span> <span class=\"token constant\">Failed</span><span class=\"token operator\">!</span> <span class=\"token constant\">Falsified</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">after</span> <span class=\"token number\">17</span> <span class=\"token hvariable\">tests</span> <span class=\"token builtin\">and</span> <span class=\"token number\">1</span> <span class=\"token hvariable\">shrink</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n<span class=\"token constant\">Mark</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Lit</span> <span class=\"token char string\">'R'</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">\"\"</span></code></pre></div><p>Much better!</p></section>\n<section><h2 id=\"wrapping-up\">Wrapping Up</h2><p>So far, we've defined a basic regex syntax tree and interpreter for it, and\nproven that it works with QuickCheck. This is a good first step, and if you're\ngoal is just to define a working regex then this is all you need!</p><p>However there is a problem with this implementation: in a worst case scenario,\nthe runtime is exponential! This means that it becomes easy to build degenerate\nregex that can take far longer than needed to match strings as they get caught\nup backtracking trying to find a match. Fortunately, this is a solved problem:\nby doing <a href=\"https://en.wikipedia.org/wiki/Thompson%27s_construction\">Thompson's construction</a>\non our regex, we can turn it into a\n<a href=\"https://en.wikipedia.org/wiki/Deterministic_finite_automaton\">deterministic finite automation</a>\nwhich has a linear runtime! I will explore doing this construction and verifying\nit with the testing infrastructure we have set up here in the next posts of this\nseries.</p></section>","frontmatter":{"title":"Compiling Regex in Haskell, Part 1","subtitle":"Building and Testing a Regex Interpreter","date":"Oct 27, 2020"}}},"pageContext":{"slug":"blog/haskell-regex-1/"}},"staticQueryHashes":[]}