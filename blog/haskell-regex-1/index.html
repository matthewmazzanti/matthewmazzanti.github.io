<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.fe2e8115db8b093fba91.css">@font-face{font-family:Fira Code;font-style:normal;font-display:swap;font-weight:400;src:url(/static/fira-code-cyrillic-ext-400-normal-d32a2f96078d9b549d75599f1097ba71.woff2) format("woff2"),url(/static/fira-code-all-400-normal-6a47133378275f52f65cb1b0daa350cd.woff) format("woff");unicode-range:U+0460-052f,U+1c80-1c88,U+20b4,U+2de0-2dff,U+a640-a69f,U+fe2e-fe2f}@font-face{font-family:Fira Code;font-style:normal;font-display:swap;font-weight:400;src:url(/static/fira-code-cyrillic-400-normal-50f767c5e2e184d2c58a510e8e7e3b64.woff2) format("woff2"),url(/static/fira-code-all-400-normal-6a47133378275f52f65cb1b0daa350cd.woff) format("woff");unicode-range:U+0400-045f,U+0490-0491,U+04b0-04b1,U+2116}@font-face{font-family:Fira Code;font-style:normal;font-display:swap;font-weight:400;src:url(data:font/woff2;base64,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) format("woff2"),url(/static/fira-code-all-400-normal-6a47133378275f52f65cb1b0daa350cd.woff) format("woff");unicode-range:U+1f??}@font-face{font-family:Fira Code;font-style:normal;font-display:swap;font-weight:400;src:url(/static/fira-code-greek-400-normal-bb28833a1b3ee46c90cf05d3728d1d83.woff2) format("woff2"),url(/static/fira-code-all-400-normal-6a47133378275f52f65cb1b0daa350cd.woff) format("woff");unicode-range:U+0370-03ff}@font-face{font-family:Fira Code;font-style:normal;font-display:swap;font-weight:400;src:url(/static/fira-code-latin-ext-400-normal-03c248ada875e694ddd54e29afdcfce3.woff2) format("woff2"),url(/static/fira-code-all-400-normal-6a47133378275f52f65cb1b0daa350cd.woff) format("woff");unicode-range:U+0100-024f,U+0259,U+1e??,U+2020,U+20a0-20ab,U+20ad-20cf,U+2113,U+2c60-2c7f,U+a720-a7ff}@font-face{font-family:Fira Code;font-style:normal;font-display:swap;font-weight:400;src:url(/static/fira-code-latin-400-normal-c6f7f2bfaccffae1d24d6945b822791e.woff2) format("woff2"),url(/static/fira-code-all-400-normal-6a47133378275f52f65cb1b0daa350cd.woff) format("woff");unicode-range:U+00??,U+0131,U+0152-0153,U+02bb-02bc,U+02c6,U+02da,U+02dc,U+2000-206f,U+2074,U+20ac,U+2122,U+2191,U+2193,U+2212,U+2215,U+feff,U+fffd}code[class*=language-],pre[class*=language-]{color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83;background:#eee8d5}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}@font-face{font-family:et-book;src:url(/static/et-book-roman-line-figures-b19f46f303d02748059251cee2aa6abb.eot);src:url(/static/et-book-roman-line-figures-b19f46f303d02748059251cee2aa6abb.eot?#iefix) format("embedded-opentype"),url(/static/et-book-roman-line-figures-10d6df6a575fb60ab98d2a7d3792642a.woff) format("woff"),url(/static/et-book-roman-line-figures-d54d0bf6aa7fcf3279d8812acb322c06.ttf) format("truetype"),url(/static/et-book-roman-line-figures-535f5953ba7e46b78cb0242b0e6b8524.svg#etbookromanosf) format("svg");font-weight:400;font-style:normal;font-display:swap}@font-face{font-family:et-book;src:url(/static/et-book-display-italic-old-style-figures-a47b89787a4f7491180c40ec69d57998.eot);src:url(/static/et-book-display-italic-old-style-figures-a47b89787a4f7491180c40ec69d57998.eot?#iefix) format("embedded-opentype"),url(/static/et-book-display-italic-old-style-figures-43eb7a3417177f8f0fff766082379da5.woff) format("woff"),url(/static/et-book-display-italic-old-style-figures-d6175af437d22f14e7cf64c370adc879.ttf) format("truetype"),url(/static/et-book-display-italic-old-style-figures-7dc8ede1f50d60b9bb7af2b78377f8bf.svg#etbookromanosf) format("svg");font-weight:400;font-style:italic;font-display:swap}@font-face{font-family:et-book;src:url(/static/et-book-bold-line-figures-7ed918f3e796962afd05f4a02fb3f84f.eot);src:url(/static/et-book-bold-line-figures-7ed918f3e796962afd05f4a02fb3f84f.eot?#iefix) format("embedded-opentype"),url(/static/et-book-bold-line-figures-1c130d09324dbeb3ba2e5a2f9d788a6f.woff) format("woff"),url(/static/et-book-bold-line-figures-5294d5d521aab523c8acd8ac96cfe4c0.ttf) format("truetype"),url(/static/et-book-bold-line-figures-1b4b875bc8327f9c37b7288df379b3b5.svg#etbookromanosf) format("svg");font-weight:700;font-style:normal;font-display:swap}@font-face{font-family:et-book-roman-old-style;src:url(/static/et-book-roman-old-style-figures-fc7b0f1d982d0029eacba5dd89bf8562.eot);src:url(/static/et-book-roman-old-style-figures-fc7b0f1d982d0029eacba5dd89bf8562.eot?#iefix) format("embedded-opentype"),url(/static/et-book-roman-old-style-figures-b1b6ddd0b0609c451978017ef81d11b9.woff) format("woff"),url(/static/et-book-roman-old-style-figures-638c7cda0684c1644411d3849e61995f.ttf) format("truetype"),url(/static/et-book-roman-old-style-figures-be6333fae60e9f2b6af41c50cd3dc6c2.svg#etbookromanosf) format("svg");font-weight:400;font-style:normal;font-display:swap}:root{--para-max-width:750px;--para-padding-left:250px;--para-padding-right:250px;--para-calc-width:calc(var(--para-max-width) + var(--para-padding-right));--note-padding:25px;--bg:#fffff8;--fg:#111;--select:#b4d5fe}@media (max-width:1300px){:root{--para-padding-left:5vw}}@media (max-width:1100px){:root{--para-padding-right:5vw;--note-padding:0px}label.margin-toggle:not(.sidenote-number){display:inline}.marginnote,.sidenote{display:none}.margin-toggle:checked+.marginnote,.margin-toggle:checked+.sidenote{display:block;float:left;clear:both;width:100%;margin:1rem 2.5%;vertical-align:baseline;position:relative}label{cursor:pointer}.fullwidth:{padding-right:var(--para-padding-right)}}.mermaid>svg{max-width:100%!important}:not(pre)>code{font-size:.8em!important;line-height:1.2}code,pre>code{line-height:1.42;-webkit-text-size-adjust:100%}code[class*=language-],pre[class*=language-]{font-family:Fira Code}.token.prompt{color:#b16286}html{font-size:15px;background-color:var(--bg);color:var(--fg)}body{margin:0}main{max-width:var(--para-calc-width);padding-left:var(--para-padding-left);margin-left:auto;margin-right:auto;font-family:et-book,Palatino,Palatino Linotype,Palatino LT STD,Book Antiqua,Georgia,serif;counter-reset:sidenote-counter}section>*{padding-right:var(--para-padding-right)}p{margin-top:1.4rem;margin-bottom:1.4rem;vertical-align:baseline}pre{max-width:var(--para-calc-width)}pre>code{font-size:.9rem;overflow-x:auto;display:block}.h1,h1{font-weight:400;font-size:3.2rem;line-height:1;margin-top:3rem;margin-bottom:.75rem}.h2,h2{font-size:2.2rem;margin-top:2rem;margin-bottom:.5rem}.h2,.h3,h2,h3{font-style:italic;font-weight:400;line-height:1}.h3,h3{font-size:1.8rem;margin-top:1.6rem;margin-bottom:.25rem}hr{display:block;height:1px;width:var(--para-max-width);border:0;border-top:1px solid #ccc;margin:1em 0;padding:0}p.subtitle{margin-left:1.5rem;margin-bottom:.75rem;font-size:1.7rem}p.subtitle,p.subtitle2{font-style:italic;margin-top:0;display:block;line-height:1}p.subtitle2{margin-left:1rem;margin-bottom:.5rem;font-size:1.4rem}.numeral{font-family:et-book-roman-old-style}.danger{color:red}article{padding:2rem 0}section{padding-top:1rem;padding-bottom:1rem}ol,p,ul{line-height:2rem}blockquote,ol,p,ul{font-size:1.4rem}blockquote p{width:var(--para-max-width);margin-right:40px}blockquote footer{width:var(--para-max-width);font-size:1.1rem;text-align:right}section>footer,section>p,section>table{max-width:var(--para-max-width)}li:not(:first-child){margin-top:.25rem}figure{padding:0;border:0;font-size:100%;font:inherit;max-width:var(--para-max-width);padding-right:var(--para-padding-right);-webkit-margin-start:0;-webkit-margin-end:0;margin:0 0 3em}figcaption,figure{vertical-align:baseline}figcaption{float:right;clear:right;margin-top:0;margin-bottom:0;font-size:1.1rem;line-height:1.6;position:relative;max-width:40%}img{max-width:100%}div.fullwidth,table.fullwidth{width:100%}div.table-wrapper{overflow-x:auto;font-family:Fira Code,Trebuchet MS,Gill Sans,Gill Sans MT,sans-serif}.sans{font-family:Fira Code,Gill Sans,Gill Sans MT,Calibri,sans-serif;letter-spacing:.03em}.sans>code{font-size:1.2rem}h1>code,h2>code,h3>code{font-size:.8em}.fullwidth{clear:both}span.newthought{font-variant:small-caps;font-size:1.2em}.iframe-wrapper{position:relative;padding-bottom:56.25%;padding-top:25px;height:0}.iframe-wrapper iframe{position:absolute;top:0;left:0;width:100%;height:100%}a:link,a:visited{color:inherit}.no-underline:link{background:unset;text-shadow:unset}.hover-underline:hover,.underline,a:link{text-decoration:none;background:linear-gradient(var(--bg),var(--bg)),linear-gradient(var(--bg),var(--bg)),linear-gradient(currentColor,currentColor);background-size:.05em 1px,.2em 1px,1px 1px;background-repeat:no-repeat,no-repeat,repeat-x;text-shadow:.03em 0 var(--bg),-.03em 0 var(--bg),0 .03em var(--bg),0 -.03em var(--bg),.06em 0 var(--bg),-.06em 0 var(--bg),.09em 0 var(--bg),-.09em 0 var(--bg),.12em 0 var(--bg),-.12em 0 var(--bg),.15em 0 var(--bg),-.15em 0 var(--bg);background-position:0 93%,100% 93%,0 93%}@media screen and (-webkit-min-device-pixel-ratio:0){.hover-underline:hover,.underline,a:link{background-position-y:87%,87%,87%}}a:link::-moz-selection,a:link::selection{text-shadow:.03em 0 var(--select),-.03em 0 var(--select),0 .03em var(--select),0 -.03em var(--select),.06em 0 var(--select),-.06em 0 var(--select),.09em 0 var(--select),-.09em 0 var(--select),.12em 0 var(--select),-.12em 0 var(--select),.15em 0 var(--select),-.15em 0 var(--select)}div.epigraph{margin:5em 0}div.epigraph>blockquote{margin-top:3em;margin-bottom:3em}div.epigraph>blockquote,div.epigraph>blockquote>p{font-style:italic}div.epigraph>blockquote>footer{font-style:normal}div.epigraph>blockquote>footer>cite{font-style:italic}.marginnote,.sidenote{float:right;clear:right;margin-right:calc(var(--para-padding-right)*-1);margin-top:0;margin-bottom:0;padding-left:var(--note-padding);padding-top:6px;width:calc(var(--para-padding-right) - var(--note-padding));font-size:1.1rem;line-height:1.3;vertical-align:baseline;position:relative}.sidenote-number{counter-increment:sidenote-counter}.sidenote-number:after,.sidenote:before{font-family:et-book-roman-old-style;position:relative;vertical-align:baseline}.sidenote-number:after{content:counter(sidenote-counter);font-size:1rem;top:-.5rem;left:.1rem}.sidenote:before{content:counter(sidenote-counter) " ";font-size:1rem;top:-.5rem}blockquote .marginnote,blockquote .sidenote{margin-right:-82%;min-width:59%;text-align:left}.marginnote>code,.sidenote>code{font-size:1rem}input.margin-toggle{display:none}label.sidenote-number{display:inline}label.margin-toggle:not(.sidenote-number){display:none}header.root{padding:1em;width:calc(100% - 2em);box-shadow:0 1px 7px #888;display:flex;align-items:center;justify-content:space-between}header.root>.title{font-size:1.5em;font-style:italic}header.root>.pages{display:flex;font-size:1.2em}header.root>.pages>a{margin:0 .5em}footer{margin-top:2rem;margin-bottom:1rem;text-align:center}</style><meta name="generator" content="Gatsby 2.26.0"/><title data-react-helmet="true">Compiling Regex in Haskell, Part 1 - Matthew Mazzanti</title><meta data-react-helmet="true" charSet="utf-8"/><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><link rel="icon" href="/favicon-32x32.png?v=71a50dbba44c78128b221b7df7bb51f1" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=71a50dbba44c78128b221b7df7bb51f1"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=71a50dbba44c78128b221b7df7bb51f1"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=71a50dbba44c78128b221b7df7bb51f1"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=71a50dbba44c78128b221b7df7bb51f1"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=71a50dbba44c78128b221b7df7bb51f1"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=71a50dbba44c78128b221b7df7bb51f1"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=71a50dbba44c78128b221b7df7bb51f1"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=71a50dbba44c78128b221b7df7bb51f1"/><link as="script" rel="preload" href="/webpack-runtime-2ff86bd874b40f2b343e.js"/><link as="script" rel="preload" href="/styles-bc72ca78f9bad9fb1f45.js"/><link as="script" rel="preload" href="/framework-dbb498007a7447f28d8e.js"/><link as="script" rel="preload" href="/app-1d3c103fa83bbdef4706.js"/><link as="script" rel="preload" href="/commons-999817166a49922d4685.js"/><link as="script" rel="preload" href="/component---src-components-blog-template-tsx-d2446c617a9565fd062c.js"/><link as="fetch" rel="preload" href="/page-data/blog/haskell-regex-1/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><header class="root"><div class="title">Matthew Mazzanti</div><div class="pages"><a href="/blog">Blog</a><a href="/">Resume</a></div></header><main><article><header><h1 class="underline" style="display:inline-block">Compiling Regex in Haskell, Part 1</h1><p class="subtitle">Building and Testing a Regex Interpreter<!-- --> - <!-- -->Oct 27, 2020</p></header><div><section><p>This post is a first in a larger series where I rebuild an
<a href="https://en.wikipedia.org/wiki/Ed_(text_editor)">ed</a> clone in Haskell. My goal is
to use this implementation as a basic platform to test out some new algorithms
I've been researching to process text handling, the first of which will be
related to regex. I hope you stay tuned!</p><p>The full source for this post and the next posts in the series is available
<a href="https://github.com/matthewmazzanti/haskell-regex">here</a>.</p></section>
<section><h2 id="the-approach">The Approach</h2><p>While a regex complier is fairly straightforward in the world of compilers, we
will be taking a very measured and holistic approach to ensure correctness at
every point in the process. We will start with building and testing a regex
<em>interpreter</em> rather than a <em>compiler</em> to act as a baseline for the rest of the
transformations we build. That way, as we apply more advanced algorithms and
optimizations, we can be sure that their implementation is correct by comparing
it to the baseline that we establish here.</p></section>
<section><h2 id="regex-ast">Regex AST</h2><p>Lets start with a basic regex AST implementation:</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token keyword">data</span> <span class="token constant">Regex</span>
    <span class="token operator">=</span> <span class="token constant">Empty</span>
    <span class="token operator">|</span> <span class="token constant">Lit</span> <span class="token constant">Char</span>
    <span class="token operator">|</span> <span class="token constant">And</span> <span class="token constant">Regex</span> <span class="token constant">Regex</span>
    <span class="token operator">|</span> <span class="token constant">Or</span> <span class="token constant">Regex</span> <span class="token constant">Regex</span>
    <span class="token operator">|</span> <span class="token constant">Mark</span> <span class="token constant">Regex</span>
    <span class="token operator">|</span> <span class="token constant">Plus</span> <span class="token constant">Regex</span>
    <span class="token operator">|</span> <span class="token constant">Star</span> <span class="token constant">Regex</span>
    <span class="token keyword">deriving</span> <span class="token constant">Show</span></code></pre></div><p>An interesting note about this data type is that any construction with it is a
valid regex. Perhaps not a sane regex, but a valid one nonetheless. This is in
line with the standard Haskell practice of making <em>illegal types
unrepresentable</em> - there's no way to get an invalid regex here, simplifying the
testing code we will write later.</p><p>Lets take a look at some example regex would look like in this data type:</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token comment">-- /abc/</span>
<span class="token constant">And</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> '<span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">-- /a|b/</span>
<span class="token constant">Or</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'b'</span><span class="token punctuation">)</span>

<span class="token comment">-- /a*|b+/</span>
<span class="token constant">Or</span> <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></div><p>While its a little verbose, its clear that any standard regex you can write can
be represented in this framework, which is a good starting point. We will be
foregoing writing a parsing frontend for this AST for the time being since I am
primarily interested in providing a regex implementation as a first pass here.</p></section>
<section><h2 id="simple-ast-interpretation">Simple AST Interpretation</h2><p>With this data-type in hand, the next order of business is to build a reference
matcher implementation:</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">match</span> <span class="token operator">::</span> <span class="token constant">Regex</span> <span class="token operator">-></span> <span class="token constant">String</span> <span class="token operator">-></span> <span class="token constant">Bool</span>
<span class="token hvariable">match</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token hvariable">isJust</span> <span class="token operator">$</span> <span class="token hvariable">find</span> <span class="token punctuation">(</span><span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span>

<span class="token hvariable">matchStream</span> <span class="token operator">::</span> <span class="token constant">Regex</span> <span class="token operator">-></span> <span class="token constant">String</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">)</span> <span class="token hvariable">syms</span>        <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">syms</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">sym</span><span class="token operator">:</span><span class="token hvariable">syms</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">c</span> <span class="token operator">==</span> <span class="token hvariable">sym</span> <span class="token keyword">then</span> <span class="token punctuation">[</span><span class="token hvariable">syms</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>'<span class="token punctuation">)</span>   <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">>>=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span>'
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Or</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>'<span class="token punctuation">)</span>    <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">&lt;></span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span>' <span class="token hvariable">syms</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token hvariable">re</span><span class="token punctuation">)</span>      <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">&lt;></span> <span class="token punctuation">[</span><span class="token hvariable">syms</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token hvariable">re</span><span class="token punctuation">)</span>      <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">>>=</span> <span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token hvariable">re</span><span class="token punctuation">)</span>
<span class="token hvariable">matchStream</span> <span class="token hvariable">star</span><span class="token operator">@</span><span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token hvariable">re</span><span class="token punctuation">)</span> <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;></span> <span class="token punctuation">[</span><span class="token hvariable">syms</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token keyword">do</span>
    <span class="token hvariable">syms</span>' <span class="token operator">&lt;-</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span>
    <span class="token keyword">if</span> <span class="token hvariable">syms</span>' <span class="token operator">/=</span> <span class="token hvariable">syms</span>
       <span class="token keyword">then</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">star</span> <span class="token hvariable">syms</span>'
       <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></code></pre></div><p>Theres a lot going on here, so lets break this down and take a closer look at
each of the component parts.</p><h3 id="the-match-function">The <code class="language-text">match</code> function</h3><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">match</span> <span class="token operator">::</span> <span class="token constant">Regex</span> <span class="token operator">-></span> <span class="token constant">String</span> <span class="token operator">-></span> <span class="token constant">Bool</span>
<span class="token hvariable">match</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token hvariable">isJust</span> <span class="token operator">$</span> <span class="token hvariable">find</span> <span class="token punctuation">(</span><span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span></code></pre></div><p>The primary match function returns whether or not a given regex and string
actually produce a full match. The bulk of the work is done in the <code class="language-text">matchStream</code>
function, which produces a list of possible remainder strings after the regex
has done the work of parsing. With that input, all we need to do is scan the
resulting strings and return <code class="language-text">True</code> if we find an empty one, indicating a match.
<code class="language-haskell"><span class="token hvariable">isJust</span> <span class="token operator">$</span> <span class="token hvariable">find</span> <span class="token punctuation">(</span><span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span></code> does this, searching through this list to find the
first instance of an empty string, indicating that the regex has parsed and
accepted the entire input.</p><p>This is also an instance of taking advantage of Haskell's lazy evaluation. In
strict languages, the <code class="language-text">matchStream</code> would have to eagerly calculate all possible
parses of the string with the regex, and return a massive list to be searched
through. Therefore, this function would more likely be written as a loop that
evaluates different options and returns whether a full match is found. However,
with lazy evaluation, this list is calculated on-the-fly as we try to find the
empty string. This allows us to have a nice separation of concerns in our
implementation, one function to parse strings and recurse, and another to
analyze that input for values we care about. All together this leads to a
cleaner, more declarative, implementation without the performance overhead this
would lead to in strict languages.</p><h3 id="simple-cases">Simple Cases</h3><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">)</span>   <span class="token hvariable">syms</span>       <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">syms</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token hvariable">_</span><span class="token punctuation">)</span>   <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token hvariable">c</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token hvariable">sym</span><span class="token operator">:</span><span class="token hvariable">syms</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">c</span> <span class="token operator">==</span> <span class="token hvariable">sym</span> <span class="token keyword">then</span> <span class="token punctuation">[</span><span class="token hvariable">syms</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token hvariable">re</span><span class="token punctuation">)</span> <span class="token hvariable">syms</span>       <span class="token operator">=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">&lt;></span> <span class="token punctuation">[</span><span class="token hvariable">syms</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Or</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>'<span class="token punctuation">)</span> <span class="token hvariable">syms</span>     <span class="token operator">=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">&lt;></span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span>' <span class="token hvariable">syms</span></code></pre></div><p>If you're not familiar, <code class="language-text">&lt;&gt;</code> is just list concatenation, and is a more generic
version of <code class="language-text">++</code>, E.G.:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>

<span class="token prompt">λ= </span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&lt;></span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span></code></pre></div><p>As previously noted, <code class="language-text">matchStream</code> takes the regex and the input string and
returns a list of possible parses of the string. The basic cases here are fairly
straightforward: </p><ul>
<li><code class="language-text">Empty</code> simply returns a singleton list of the input string.</li>
<li><code class="language-text">Lit</code> requires that the string be non-empty, and if so, advances the input one
character. In all other cases it fails and terminates this branch of the
parse.</li>
<li><code class="language-text">Mark</code> provides two choices: either the result of matching the expression, or
the original stream if we skip the regex.</li>
<li><code class="language-text">Or</code> just combines the lists produced by the first regex with those of the
second, with the same starting strings as the input.</li>
</ul><h3 id="and-operator"><code class="language-text">And</code> Operator</h3><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>'<span class="token punctuation">)</span> <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">>>=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span>'</code></pre></div><p>In the case of the <code class="language-text">And</code> regex we take advantage of the <code class="language-text">&gt;&gt;=</code> (pronounced
"bind") function defined for Lists. This function has type</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token punctuation">(</span><span class="token operator">>>=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span></code></pre></div><p>It takes a list, and a function to produce a list for each value in the list
values, and produces a single new list of all options. This allows us to
describe compounding actions that may produce multiple results, or none at all,
in a very succinct way. In practice (note: <code class="language-ghci">λ<span class="token operator">=</span></code> is my prompt for ghci,
the Haskell interpreter/repl):</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token keyword">let</span> <span class="token hvariable">rep</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">i</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">..</span><span class="token hvariable">i</span><span class="token punctuation">]</span>

<span class="token prompt">λ= </span><span class="token hvariable">rep</span> <span class="token number">0</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token prompt">λ= </span><span class="token hvariable">rep</span> <span class="token number">2</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>

<span class="token prompt">λ= </span><span class="token hvariable">rep</span> <span class="token number">4</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>

<span class="token prompt">λ= </span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">>>=</span> <span class="token hvariable">rep</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>

<span class="token prompt">λ= </span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">>>=</span> <span class="token hvariable">rep</span> <span class="token operator">>>=</span> <span class="token hvariable">rep</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span></code></pre></div><p>We start with a simple function <code class="language-text">rep</code> which, for each value in the list,
produces a new list of 1 to <code class="language-text">i</code>. By binding <code class="language-text">rep</code> together multiple times, we
produce a single list which is a combination of all of these choices.  We can
also terminate a path, as in the case of 0, by returning an empty list.
Repeating this process again tends to have a multiplicative effect, with each
list exponentially longer than the last as the possible choices build up.</p><p>In the case of <code class="language-text">matchStream</code>, this behavior is exactly what we want: All
possible parses of the first sub-regex should be fed to all parses of the second
sub-regex, resulting in a list of all possible parses for the combined
operators. Once again, by example:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token comment">-- /a?/</span>
<span class="token prompt">λ= </span><span class="token keyword">let</span> <span class="token hvariable">mark</span> <span class="token operator">=</span> <span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span>

<span class="token prompt">λ= </span><span class="token hvariable">matchStream</span> <span class="token hvariable">mark</span> <span class="token string">"a"</span>
<span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">]</span>

<span class="token comment">-- /a?a?/</span>
<span class="token prompt">λ= </span><span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token hvariable">mark</span> <span class="token hvariable">mark</span><span class="token punctuation">)</span> <span class="token string">"aa"</span>
<span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"aa"</span><span class="token punctuation">]</span>

<span class="token prompt">λ= </span><span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token hvariable">mark</span> <span class="token hvariable">mark</span><span class="token punctuation">)</span> <span class="token string">"a"</span>
<span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">]</span></code></pre></div><p>The most interesting case here is where <code class="language-text">And mark mark</code> is matched against <code class="language-text">&quot;a&quot;</code>
producing three choices: </p><ul>
<li>The first <code class="language-text">Mark</code> matching and the second <code class="language-text">Mark</code> getting skipped.</li>
<li>The first <code class="language-text">Mark</code> getting skipped and the second <code class="language-text">Mark</code> matching.</li>
<li>Both <code class="language-text">Marks</code> getting skipped.</li>
<li>Both <code class="language-text">Marks</code> matching. This choice gets culled, as it causes the second
literal to fail and produce <code class="language-text">[]</code>.</li>
</ul><h3 id="the-star-operator">The <code class="language-text">Star</code> Operator</h3><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">matchStream</span> <span class="token hvariable">star</span><span class="token operator">@</span><span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token hvariable">re</span><span class="token punctuation">)</span> <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;></span> <span class="token punctuation">[</span><span class="token hvariable">syms</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token keyword">do</span>
    <span class="token hvariable">syms</span>' <span class="token operator">&lt;-</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span>
    <span class="token keyword">if</span> <span class="token hvariable">syms</span>' <span class="token operator">/=</span> <span class="token hvariable">syms</span>
       <span class="token keyword">then</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">star</span> <span class="token hvariable">syms</span>'
       <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></code></pre></div><p>The <code class="language-text">Star</code> operator is the most complex of the lot, and the only one to take
advantage of <code class="language-text">do</code> notation. Lets break it down further.</p><p>We start with <code class="language-haskell"><span class="token punctuation">(</span><span class="token operator">&lt;></span> <span class="token punctuation">[</span><span class="token hvariable">syms</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code>. This leverages
<a href="https://wiki.haskell.org/Infix_operator">infix</a> and
<a href="https://wiki.haskell.org/Currying">curried</a> functions at the same time. It
describes appending the unadvanced string to the rest of the strings produced by
the <code class="language-text">Star</code> operator.</p><p>Next is the do notation which is a bit trickier. We bind the result of matching
the string to a new variable <code class="language-text">syms&#39;</code>, and check that <code class="language-text">syms&#39;</code> is distinct from
the original <code class="language-text">syms</code> variable. This is needed as otherwise if the <code class="language-text">re</code> operator
matched no symbols, then we land in an infinite loop of matching no symbols as
we recurse. If our <code class="language-text">syms&#39;</code> variable is different we recurse, otherwise
terminating.</p><p>An example:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">"aaa"</span>
<span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"aa"</span><span class="token punctuation">,</span><span class="token string">"aaa"</span><span class="token punctuation">]</span></code></pre></div><p>From this example you can see the resulting parses, in priority order. The first
case is a full match- the entire input stream is consumed. From there, we
backtrack adding another <code class="language-text">&#39;a&#39;</code> char back into the stream so that other operators
can match if needed.</p><h3 id="the-plus-operator">The <code class="language-text">Plus</code> Operator</h3><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token hvariable">re</span><span class="token punctuation">)</span> <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">>>=</span> <span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token hvariable">re</span><span class="token punctuation">)</span></code></pre></div><p>The <code class="language-text">Plus</code> operator leans on the <code class="language-text">Star</code> operator, since they are nearly the
same, but imposes that the regex match at least once before repeating the match
in the same manner as the <code class="language-text">And</code> operator.</p></section>
<section><h2 id="testing-the-implementation">Testing the implementation</h2><p>So far we've defined a simple interpreter, but done nothing to ensure that it
works! Lets lay down some basic sanity tests:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token hvariable">match</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token string">"a"</span>
<span class="token constant">True</span>

<span class="token prompt">λ= </span><span class="token hvariable">match</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token string">"aa"</span>
<span class="token constant">False</span>

<span class="token prompt">λ= </span><span class="token hvariable">match</span> <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">"ab"</span> 
<span class="token constant">True</span>

<span class="token prompt">λ= </span><span class="token hvariable">match</span> <span class="token punctuation">(</span><span class="token constant">Or</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">"a"</span>
<span class="token constant">True</span>

<span class="token prompt">λ= </span><span class="token hvariable">match</span> <span class="token punctuation">(</span><span class="token constant">Or</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">"b"</span>
<span class="token constant">True</span>

<span class="token prompt">λ= </span><span class="token hvariable">match</span> <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">"aaa"</span> 
<span class="token constant">True</span>

<span class="token prompt">λ= </span><span class="token hvariable">match</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">""</span>
<span class="token constant">False</span>

<span class="token prompt">λ= </span><span class="token hvariable">match</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">"aaa"</span>
<span class="token constant">True</span></code></pre></div><p>Having to think up test cases for every relevant combination of regex and string
and test them one at a time gets old pretty quickly, at least for me. Luckily,
as previously mentioned, any data that can be represented by the <code class="language-text">Regex</code> type is
a valid regex, perhaps we can use that to remove some of the repetitiveness
here?</p><h3 id="quickcheck-property-testing">QuickCheck Property Testing</h3><p>Enter QuickCheck, a library to automate the testing of code through random test
case generation. It provides facilities for generating random data that can be
fed into your implementation, and then checks that properties that you define
for that implementation always hold. If they do not, QuickCheck gives you a
counter example to debug. When your input data is complex and you need lots of
test cases to ensure everything works, QuickCheck is significantly easier to use
than specifying test cases and their results one at a time.</p><p>The first thing we have to do is define an <code class="language-text">Arbitrary</code> instance for our regex
data type so that we can generate random regex to test against. This can be
automated with Haskell's generic data types, however I've elected to do this
manually to get a better feel for the internal workings:</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token keyword">instance</span> <span class="token constant">Arbitrary</span> <span class="token constant">Regex</span> <span class="token keyword">where</span>
  <span class="token hvariable">arbitrary</span> <span class="token operator">=</span> <span class="token hvariable">sized</span> <span class="token punctuation">(</span><span class="token hvariable">genRegex</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">where</span>
      <span class="token hvariable">genRegex</span> <span class="token hvariable">depth</span> <span class="token hvariable">size</span> <span class="token operator">=</span> <span class="token hvariable">frequency</span>
          <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token hvariable">depth</span><span class="token punctuation">,</span> <span class="token constant">Lit</span> <span class="token operator">&lt;$></span> <span class="token hvariable">arbitraryASCIIChar</span><span class="token punctuation">)</span>
          <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">depth</span><span class="token punctuation">,</span> <span class="token hvariable">pure</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
          <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">size</span><span class="token punctuation">,</span>  <span class="token hvariable">genTwo</span> <span class="token constant">And</span><span class="token punctuation">)</span>
          <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">size</span><span class="token punctuation">,</span>  <span class="token hvariable">genTwo</span> <span class="token constant">Or</span><span class="token punctuation">)</span>
          <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">size</span><span class="token punctuation">,</span>  <span class="token hvariable">genOne</span> <span class="token constant">Mark</span><span class="token punctuation">)</span>
          <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">size</span><span class="token punctuation">,</span>  <span class="token hvariable">genOne</span> <span class="token constant">Star</span><span class="token punctuation">)</span>
          <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">size</span><span class="token punctuation">,</span>  <span class="token hvariable">genOne</span> <span class="token constant">Plus</span><span class="token punctuation">)</span>
          <span class="token punctuation">]</span>
        <span class="token keyword">where</span> <span class="token hvariable">genRegex</span>' <span class="token operator">=</span> <span class="token hvariable">genRegex</span> <span class="token punctuation">(</span><span class="token hvariable">depth</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token hvariable">size</span>
              <span class="token hvariable">genOne</span> <span class="token hvariable">fn</span> <span class="token operator">=</span> <span class="token hvariable">fn</span> <span class="token operator">&lt;$></span> <span class="token hvariable">genRegex</span>'
              <span class="token hvariable">genTwo</span> <span class="token hvariable">fn</span> <span class="token operator">=</span> <span class="token hvariable">fn</span> <span class="token operator">&lt;$></span> <span class="token hvariable">genRegex</span>' <span class="token operator">&lt;*></span> <span class="token hvariable">genRegex</span>'</code></pre></div><p>Once again, theres a lot going on here so lets break it down.</p><h3 id="size-and-frequency">Size and Frequency</h3><p>The first thing to note is the <code class="language-text">size</code> parameter of <code class="language-text">genRegex</code> and <code class="language-text">sized</code>
function used to call <code class="language-text">genRegex</code> at the top level. We use the size parameter to
roughly tune the final size of the regex, so that in general as the size param
goes up, the average size of the regex increases. QuickCheck increases the
<code class="language-text">size</code> parameter as it tests more cases, so that it can start with simple cases
and move on to more complex ones.</p><p>This size parameter is used in the <code class="language-text">frequency</code> function to bias the generation
of our data. To explain further, lets start with the simpler <code class="language-text">oneof</code> function.
Using <code class="language-text">oneof</code> we can build a simple boolean generator as follows:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token keyword">let</span> <span class="token hvariable">boolGen</span> <span class="token operator">=</span> <span class="token hvariable">oneof</span> <span class="token punctuation">[</span><span class="token hvariable">pure</span> <span class="token constant">True</span><span class="token punctuation">,</span> <span class="token hvariable">pure</span> <span class="token constant">False</span><span class="token punctuation">]</span>

<span class="token prompt">λ= </span><span class="token hvariable">generate</span> <span class="token operator">$</span> <span class="token hvariable">sized</span> <span class="token number">10</span> <span class="token operator">$</span> <span class="token hvariable">listOf</span> <span class="token hvariable">boolGen</span>
<span class="token punctuation">[</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">]</span></code></pre></div><p>Each time <code class="language-text">generate</code> is called on this generator it chooses, with equal
probability, an item in the list and returns it. Useful, but often you need more
control, which is where the  <code class="language-text">frequency</code> function comes in. <code class="language-text">frequency</code> allows
us to bias the generator to produce certain values more often. For example, if
we want to produce <code class="language-text">True</code> with a 75% chance and <code class="language-text">False</code> with a 25% chance we
define it as follows:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token keyword">let</span> <span class="token hvariable">boolGen</span> <span class="token operator">=</span> <span class="token hvariable">frequency</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token hvariable">pure</span> <span class="token constant">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token hvariable">pure</span> <span class="token constant">False</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token prompt">λ= </span><span class="token hvariable">generate</span> <span class="token operator">$</span> <span class="token hvariable">sized</span> <span class="token number">10</span> <span class="token operator">$</span> <span class="token hvariable">listOf</span> <span class="token hvariable">boolGen</span>
<span class="token punctuation">[</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">False</span><span class="token punctuation">]</span></code></pre></div><p>As you can see, we are now generating <code class="language-text">True</code> much more often than <code class="language-text">False</code> unlike
our example with <code class="language-text">oneof</code>.</p><p>In our regex generator, we use the <code class="language-text">frequency</code> function to tune how large the
resulting structure will be by biasing the generator based on the <code class="language-text">size</code> and
<code class="language-text">depth</code> parameters. <code class="language-text">size</code> is set by QuickCheck, up to 30.  <code class="language-text">depth</code> is our own
parameter, starting at 1 and doubling each time we recurse further into the
regex we are generating. We tie the <code class="language-text">depth</code> parameter to the terminating values
<code class="language-text">Empty</code> and <code class="language-text">Lit</code> so that as our generator recurses further there is a greater
and greater chance that generation will stop. We pass <code class="language-text">size</code> into the rest of
the parameters, giving us a baseline probability for continuing generation and
allowing us to make larger structures. As <code class="language-text">size</code> grows, it becomes more likely
that the generated regex will recurse deeper to the point where <code class="language-text">depth</code> gets big
enough to overcome it.</p><p>Lets see this in action:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token hvariable">generate</span> <span class="token punctuation">(</span><span class="token hvariable">resize</span> <span class="token number">1</span> <span class="token operator">$</span> <span class="token hvariable">arbitrary</span> <span class="token operator">::</span> <span class="token constant">Gen</span> <span class="token constant">Regex</span><span class="token punctuation">)</span>
<span class="token constant">Plus</span> <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>

<span class="token prompt">λ= </span><span class="token hvariable">generate</span> <span class="token punctuation">(</span><span class="token hvariable">resize</span> <span class="token number">1</span> <span class="token operator">$</span> <span class="token hvariable">arbitrary</span> <span class="token operator">::</span> <span class="token constant">Gen</span> <span class="token constant">Regex</span><span class="token punctuation">)</span>
<span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'0'</span><span class="token punctuation">)</span>

<span class="token prompt">λ= </span><span class="token hvariable">generate</span> <span class="token punctuation">(</span><span class="token hvariable">resize</span> <span class="token number">10</span> <span class="token operator">$</span> <span class="token hvariable">arbitrary</span> <span class="token operator">::</span> <span class="token constant">Gen</span> <span class="token constant">Regex</span><span class="token punctuation">)</span>
<span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token prompt">λ= </span><span class="token hvariable">generate</span> <span class="token punctuation">(</span><span class="token hvariable">resize</span> <span class="token number">10</span> <span class="token operator">$</span> <span class="token hvariable">arbitrary</span> <span class="token operator">::</span> <span class="token constant">Gen</span> <span class="token constant">Regex</span><span class="token punctuation">)</span>
<span class="token constant">Or</span>
  <span class="token punctuation">(</span><span class="token constant">And</span>
    <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token punctuation">(</span><span class="token constant">And</span>
      <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">':'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Or</span> <span class="token constant">Empty</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token punctuation">(</span><span class="token constant">Or</span>
    <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Or</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></div><p>As you can see from these examples, small size values tend to build small
structures, whereas larger size values tend to build larger values. Exactly what
we need to build a good <code class="language-text">arbitrary</code>!</p><h3 id="generating-random-strings">Generating Random Strings</h3><p>Everything we've done thus far is interesting, however we're still missing the
critical piece to testing the <code class="language-text">match</code> implementation: a <code class="language-text">String</code> to match
against! Naïvely, we could just use the <code class="language-text">Arbitrary</code> instance on <code class="language-text">String</code>
provided by QuickCheck to generate a random string of random length, however
this poses a couple of problems:</p><ul>
<li>We won't know if a randomly generated string <em>should</em> match, so we can't
decide whether the return value of <code class="language-text">match</code> is valid or not.</li>
<li>The arbitrary instance for <code class="language-text">String</code> will generate strings that are too random.
The vast majority of these strings will have nothing to do with our regex, and
will not match. This means churning through a lot of data to find cases that
do match, increasing the length of our testing process.</li>
</ul><p>We need to be able to generate random strings that <em>should always</em> match the
given regex, in order to test that our implementation hasn't missed anything.
Thankfully computer science has already thought of this: grammars, the class of
mathematical objects that regex are a part of, can be used to both match strings
as well as generate them.</p><p>What we need to do is to build a function of type</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">genString</span> <span class="token operator">::</span> <span class="token constant">Regex</span> <span class="token operator">-></span> <span class="token constant">Gen</span> <span class="token constant">String</span></code></pre></div><p>This would allow us to build a generator that only creates valid strings of a
given <code class="language-text">Regex</code>, nicely solving the problems described above. My implementation
looks like this:</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">genString</span> <span class="token operator">::</span> <span class="token constant">Regex</span> <span class="token operator">-></span> <span class="token constant">Gen</span> <span class="token constant">String</span>
<span class="token hvariable">genString</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">)</span>        <span class="token operator">=</span> <span class="token hvariable">pure</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">genString</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token hvariable">c</span><span class="token punctuation">)</span>        <span class="token operator">=</span> <span class="token hvariable">pure</span> <span class="token punctuation">[</span><span class="token hvariable">c</span><span class="token punctuation">]</span>
<span class="token hvariable">genString</span> <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>'<span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;></span><span class="token punctuation">)</span> <span class="token operator">&lt;$></span> <span class="token hvariable">genString</span> <span class="token hvariable">re</span> <span class="token operator">&lt;*></span> <span class="token hvariable">genString</span> <span class="token hvariable">re</span>'
<span class="token hvariable">genString</span> <span class="token punctuation">(</span><span class="token constant">Or</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>'<span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token hvariable">oneof</span> <span class="token punctuation">[</span><span class="token hvariable">genString</span> <span class="token hvariable">re</span><span class="token punctuation">,</span> <span class="token hvariable">genString</span> <span class="token hvariable">re</span>'<span class="token punctuation">]</span>
<span class="token hvariable">genString</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token hvariable">re</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token hvariable">oneof</span> <span class="token punctuation">[</span><span class="token hvariable">pure</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">genString</span> <span class="token hvariable">re</span><span class="token punctuation">]</span>
<span class="token hvariable">genString</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token hvariable">re</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;></span><span class="token punctuation">)</span> <span class="token operator">&lt;$></span> <span class="token hvariable">genString</span> <span class="token hvariable">re</span> <span class="token operator">&lt;*></span> <span class="token hvariable">genString</span> <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token hvariable">re</span><span class="token punctuation">)</span>
<span class="token hvariable">genString</span> <span class="token hvariable">star</span><span class="token operator">@</span><span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token hvariable">re</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">oneof</span>
    <span class="token punctuation">[</span> <span class="token hvariable">pure</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;></span><span class="token punctuation">)</span> <span class="token operator">&lt;$></span> <span class="token hvariable">genString</span> <span class="token hvariable">re</span> <span class="token operator">&lt;*></span> <span class="token hvariable">genString</span> <span class="token hvariable">star</span>
    <span class="token punctuation">]</span></code></pre></div><p>This function is effectively the inverse of the <code class="language-text">match</code> function, generating
values that should always match the given regex fragment and recursing to
generate more of the string from more of the regex. Lets see it in action:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token hvariable">generate</span> <span class="token operator">$</span> <span class="token hvariable">listOf</span> <span class="token operator">$</span> <span class="token hvariable">genString</span> <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token punctuation">(</span><span class="token constant">Or</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">"bb"</span><span class="token punctuation">,</span><span class="token string">"aa"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"bbb"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"aab"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">]</span>

<span class="token prompt">λ= </span><span class="token hvariable">generate</span> <span class="token operator">$</span> <span class="token hvariable">listOf</span> <span class="token operator">$</span> <span class="token hvariable">genString</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">"ab"</span><span class="token punctuation">,</span><span class="token string">"ab"</span><span class="token punctuation">,</span><span class="token string">"abaababa"</span><span class="token punctuation">,</span><span class="token string">"abaa"</span><span class="token punctuation">,</span><span class="token string">"ab"</span><span class="token punctuation">,</span><span class="token string">"aba"</span><span class="token punctuation">,</span><span class="token string">"ab"</span><span class="token punctuation">,</span><span class="token string">"aababa"</span><span class="token punctuation">]</span></code></pre></div><h3 id="bringing-it-all-together">Bringing it all Together</h3><p>With the ability go generate arbitrary regex and valid strings from those regex,
we can now build the core test function:</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">test</span> <span class="token operator">::</span> <span class="token constant">Regex</span> <span class="token operator">-></span> <span class="token constant">Property</span>
<span class="token hvariable">test</span> <span class="token hvariable">re</span> <span class="token operator">=</span> <span class="token hvariable">forAll</span> <span class="token punctuation">(</span><span class="token hvariable">genString</span> <span class="token hvariable">re</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">match</span> <span class="token hvariable">re</span><span class="token punctuation">)</span></code></pre></div><p>Here we take advantage of the <code class="language-text">forAll</code> function from QuickCheck. This allows us
to generate a random string value for the <code class="language-text">match</code> function, while still tying it
to the regex that we are testing.</p><p>To run the test we just pass it into the <code class="language-text">quickCheck</code> function:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token hvariable">quickCheck</span> <span class="token hvariable">test</span>
<span class="token operator">+++</span> <span class="token constant">OK</span><span class="token punctuation">,</span> <span class="token hvariable">passed</span> <span class="token number">100</span> <span class="token hvariable">tests</span><span class="token punctuation">.</span></code></pre></div><p>Now at the time of writing, I have already fixed the bugs associated with this
implementation, so we don't get to see QuickCheck in action giving a
counterexample. Lets intentionally introduce a bug in the <code class="language-text">Mark</code> case and see if
QuickCheck can find it.</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">matchStream</span> <span class="token operator">::</span> <span class="token constant">Regex</span> <span class="token operator">-></span> <span class="token constant">String</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">)</span> <span class="token hvariable">syms</span>        <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">syms</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">sym</span><span class="token operator">:</span><span class="token hvariable">syms</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">c</span> <span class="token operator">==</span> <span class="token hvariable">sym</span> <span class="token keyword">then</span> <span class="token punctuation">[</span><span class="token hvariable">syms</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>'<span class="token punctuation">)</span>   <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">>>=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span>'
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Or</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>'<span class="token punctuation">)</span>    <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">&lt;></span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span>' <span class="token hvariable">syms</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token hvariable">re</span><span class="token punctuation">)</span>      <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token comment">-- &lt;> [syms]</span>
<span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token hvariable">re</span><span class="token punctuation">)</span>      <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span> <span class="token operator">>>=</span> <span class="token hvariable">matchStream</span> <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token hvariable">re</span><span class="token punctuation">)</span>
<span class="token hvariable">matchStream</span> <span class="token hvariable">star</span><span class="token operator">@</span><span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token hvariable">re</span><span class="token punctuation">)</span> <span class="token hvariable">syms</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;></span> <span class="token punctuation">[</span><span class="token hvariable">syms</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token keyword">do</span>
    <span class="token hvariable">syms</span>' <span class="token operator">&lt;-</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">re</span> <span class="token hvariable">syms</span>
    <span class="token keyword">if</span> <span class="token hvariable">syms</span>' <span class="token operator">/=</span> <span class="token hvariable">syms</span>
       <span class="token keyword">then</span> <span class="token hvariable">matchStream</span> <span class="token hvariable">star</span> <span class="token hvariable">syms</span>'
       <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></code></pre></div><p>Running QuickCheck again:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token hvariable">quickCheck</span> <span class="token hvariable">test</span>
<span class="token operator">***</span> <span class="token constant">Failed</span><span class="token operator">!</span> <span class="token constant">Falsified</span> <span class="token punctuation">(</span><span class="token hvariable">after</span> <span class="token number">8</span> <span class="token hvariable">tests</span><span class="token punctuation">)</span><span class="token operator">:</span>  
<span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'L'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Or</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token constant">Empty</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">""</span></code></pre></div><p>So it found the bug, and gave us a counterexample.  This is great, but the
counterexample is long and difficult to follow, especially if you don't know
what the issue really was. This is where QuickCheck's <em>shrinking</em> capability
comes in: when the test function finds a counterexample, it then runs the
<code class="language-text">shrink</code> function to try out different variations of smaller inputs so that it
can give you better results.</p><p>Lets implement the shrink function for our <code class="language-text">Arbitrary</code> instance:</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token keyword">instance</span> <span class="token constant">Arbitrary</span> <span class="token constant">Regex</span> <span class="token keyword">where</span>
  <span class="token operator">...</span>

  <span class="token hvariable">shrink</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token hvariable">_</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token hvariable">shrink</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token hvariable">shrink</span> <span class="token punctuation">(</span><span class="token constant">And</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>'<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">shrinkTwo</span> <span class="token constant">And</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>'
  <span class="token hvariable">shrink</span> <span class="token punctuation">(</span><span class="token constant">Or</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>'<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token hvariable">shrinkTwo</span> <span class="token constant">Or</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>'
  <span class="token hvariable">shrink</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token hvariable">re</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token hvariable">shrinkOne</span> <span class="token constant">Mark</span> <span class="token hvariable">re</span>
  <span class="token hvariable">shrink</span> <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token hvariable">re</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token hvariable">shrinkOne</span> <span class="token constant">Star</span> <span class="token hvariable">re</span>
  <span class="token hvariable">shrink</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token hvariable">re</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token hvariable">shrinkOne</span> <span class="token constant">Plus</span> <span class="token hvariable">re</span>


<span class="token hvariable">shrinkOne</span> <span class="token operator">::</span> <span class="token constant">Arbitrary</span> <span class="token hvariable">a</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">shrinkOne</span> <span class="token hvariable">fn</span> <span class="token hvariable">re</span> <span class="token operator">=</span> <span class="token hvariable">join</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token hvariable">re</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">fn</span> <span class="token operator">&lt;$></span> <span class="token hvariable">x</span><span class="token punctuation">]</span>
  <span class="token keyword">where</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">shrink</span> <span class="token hvariable">re</span>


<span class="token hvariable">shrinkTwo</span> <span class="token operator">::</span> <span class="token constant">Arbitrary</span> <span class="token hvariable">a</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">shrinkTwo</span> <span class="token hvariable">fn</span> <span class="token hvariable">re</span> <span class="token hvariable">re</span>' <span class="token operator">=</span> <span class="token hvariable">join</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token hvariable">re</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">y</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token hvariable">re</span>'<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">fn</span> <span class="token operator">&lt;$></span> <span class="token hvariable">x</span> <span class="token operator">&lt;*></span> <span class="token hvariable">y</span><span class="token punctuation">]</span>
  <span class="token keyword">where</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">shrink</span> <span class="token hvariable">re</span>
        <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">shrink</span> <span class="token hvariable">re</span>'</code></pre></div><p>The shrink function for this instance is of type <code class="language-haskell"><span class="token constant">Regex</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token constant">Regex</span><span class="token punctuation">]</span></code>, the
idea being that for a given regex, we return a list of smaller values that
QuickCheck can test against to find a better counterexample.</p><p>The base cases are <code class="language-text">Lit</code> and <code class="language-text">Empty</code>, where we return empty lists, since these
are terminating values that can't be shrunk any further.</p><p>I also defined the <code class="language-text">shrinkOne</code> function that lets us shrink a regex with a
single argument constructor, and <code class="language-text">shrinkTwo</code> that does the same with a
two-argument constructor. In order, these return:</p><ul>
<li>All the shrinks of the inner regex.</li>
<li>The original inner regex.</li>
<li>All the shrinks of the inner regex, within the original constructor.</li>
</ul><p>By example:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token hvariable">shrink</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Star</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">,</span> <span class="token constant">Star</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token prompt">λ= </span><span class="token hvariable">shrink</span> <span class="token punctuation">(</span><span class="token constant">Or</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Plus</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token constant">Lit</span> <span class="token char string">'a'</span><span class="token punctuation">,</span> <span class="token constant">Lit</span> <span class="token char string">'b'</span><span class="token punctuation">,</span> <span class="token constant">Plus</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre></div><p>As you can see, when given a regex, the shrink function will generate all
combinations of sub-regex so that we can test against them.</p><p>With shrink defined, lets test the bugged version one more time to see if our
error output has improved:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token hvariable">quickCheck</span> <span class="token hvariable">test</span>
<span class="token operator">***</span> <span class="token constant">Failed</span><span class="token operator">!</span> <span class="token constant">Falsified</span> <span class="token punctuation">(</span><span class="token hvariable">after</span> <span class="token number">9</span> <span class="token hvariable">tests</span> <span class="token builtin">and</span> <span class="token number">1</span> <span class="token hvariable">shrink</span><span class="token punctuation">)</span><span class="token operator">:</span>
<span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'S'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">""</span></code></pre></div><p>This is certainly an improvement, but is still more complex than we'd hope - we
should only see a single <code class="language-text">Mark</code> in our error output.</p><p>Taking a look at the verbose output gives us a hint to the issue:</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token hvariable">quickCheck</span> <span class="token punctuation">(</span><span class="token hvariable">verbose</span> <span class="token hvariable">test</span><span class="token punctuation">)</span>
<span class="token operator">...</span>

<span class="token constant">Passed</span><span class="token operator">:</span>
<span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'S'</span><span class="token punctuation">)</span>
<span class="token string">"S"</span>

<span class="token operator">***</span> <span class="token constant">Failed</span><span class="token operator">!</span> <span class="token constant">Falsified</span> <span class="token punctuation">(</span><span class="token hvariable">after</span> <span class="token number">9</span> <span class="token hvariable">tests</span> <span class="token builtin">and</span> <span class="token number">1</span> <span class="token hvariable">shrink</span><span class="token punctuation">)</span><span class="token operator">:</span>
<span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'S'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">""</span></code></pre></div><p>When QuickCheck runs the tests again, its generating a single random string for
the input to the regex. As we can see you can get unlucky and generate a
matching string for the regex. In our example our bugged input should be <code class="language-text">&quot;&quot;</code>,
however for the <code class="language-text">Mark (Lit &#39;S&#39;)</code> shrink the only input generated was <code class="language-text">&quot;S&quot;</code>. To
improve the odds of getting a minimal counterexample, we can simply increase the
number of strings generated and passed to test our regex:</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">test</span> <span class="token operator">::</span> <span class="token constant">Regex</span> <span class="token operator">-></span> <span class="token constant">Property</span>
<span class="token hvariable">test</span> <span class="token hvariable">re</span> <span class="token operator">=</span> <span class="token hvariable">conjoin</span> <span class="token operator">$</span> <span class="token builtin">replicate</span> <span class="token number">10</span> <span class="token operator">$</span> <span class="token hvariable">forAll</span> <span class="token punctuation">(</span><span class="token hvariable">genString</span> <span class="token hvariable">re</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">match</span> <span class="token hvariable">re</span><span class="token punctuation">)</span></code></pre></div><p>Now instead of testing a single random input string, we generate 10. This makes
it significantly less likely that we will just skip over failing counterexamples
by generating the wrong string.</p><div class="gatsby-highlight" data-language="ghci"><pre class="language-ghci"><code class="language-ghci"><span class="token prompt">λ= </span><span class="token hvariable">quickCheck</span> <span class="token hvariable">test</span>
<span class="token operator">***</span> <span class="token constant">Failed</span><span class="token operator">!</span> <span class="token constant">Falsified</span> <span class="token punctuation">(</span><span class="token hvariable">after</span> <span class="token number">17</span> <span class="token hvariable">tests</span> <span class="token builtin">and</span> <span class="token number">1</span> <span class="token hvariable">shrink</span><span class="token punctuation">)</span><span class="token operator">:</span>
<span class="token constant">Mark</span> <span class="token punctuation">(</span><span class="token constant">Lit</span> <span class="token char string">'R'</span><span class="token punctuation">)</span>
<span class="token string">""</span></code></pre></div><p>Much better!</p></section>
<section><h2 id="wrapping-up">Wrapping Up</h2><p>So far, we've defined a basic regex syntax tree and interpreter for it, and
proven that it works with QuickCheck. This is a good first step, and if your
goal is just to define a working regex engine then this is all you need!</p><p>However there is a problem with this implementation: in a worst case scenario,
the runtime is exponential, as it has to backtrack through all possible
combinations of how the regex could match the string. This means that it becomes easy to build degenerate
regex that can take far longer than needed to match strings, since they get
caught up backtracking trying to find a match.</p><p>Fortunately, comp-sci comes to the rescue again! By doing
<a href="https://en.wikipedia.org/wiki/Thompson%27s_construction">Thompson's construction</a>
on our regex, we can turn it into a
<a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">deterministic finite automation</a>
with a linear runtime. I will explore doing this construction and verifying it
with the testing infrastructure we have set up here in the next posts of this
series.</p></section></div></article></main><footer>© <!-- -->2020<!-- -->, Matthew Mazzanti</footer></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/blog/haskell-regex-1/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-a0c9186328768889dad2.js"],"app":["/app-1d3c103fa83bbdef4706.js"],"component---src-components-blog-template-tsx":["/component---src-components-blog-template-tsx-d2446c617a9565fd062c.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-9b5388a82ce6b87ddf76.js"],"component---src-pages-blog-tsx":["/component---src-pages-blog-tsx-fbcf5d2d648cec160e92.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-c3bd5b7510826afc8b8d.js"]};/*]]>*/</script><script src="/polyfill-a0c9186328768889dad2.js" nomodule=""></script><script src="/component---src-components-blog-template-tsx-d2446c617a9565fd062c.js" async=""></script><script src="/commons-999817166a49922d4685.js" async=""></script><script src="/app-1d3c103fa83bbdef4706.js" async=""></script><script src="/framework-dbb498007a7447f28d8e.js" async=""></script><script src="/styles-bc72ca78f9bad9fb1f45.js" async=""></script><script src="/webpack-runtime-2ff86bd874b40f2b343e.js" async=""></script></body></html>